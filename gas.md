7. Исцртавање графикона

###### 7. Исцртавање графикона

Веома корисну одлику MATLAB-а представљају његове могућности за визуелну

репрезентацију података кроз различите врсте дводимензионалих (функција

_plot_ ) и тродимензионалних графикона (функција _plot3_ ).

Подаци се исцртавају као уређени парови координата коришћењем следећих

врста графикона:

```
− линијски (функција plot ),
− хистограми (функција bar ),
```
```
− дискретни (функција stem ),
− степенасти (функција stairs ) и
```
```
− кружни графикони (функција pie ).
```
Поред података, у MATLAB-у је могуће исцртати и фунцкије (функција _fplot_ ).

Исцртаним графиконима могуће је додати наслове и легенде, означити им осе,

форматирати врсту, дебљину и боју линија, али и додати стрелице, текст и

друге објекте.

**Дводимензионално исцртавање података**

За линијско исцртавање података најчешће се користи функција _plot_ која може

произвести различите графиконе у зависности од улазних аргумената. Подаци

за исцртавање се задају у оквиру прва два аргумента функције, након чега

следе аргументи за форматирање графикона.

```
plot(x,y,‘format_linije’,‘ime_svojstva’,vrednost_svojstva)
```
Улазни аргументи функције су:

- вектор _x_ са подацима које желимо да исцртамо на хоризонталној оси
    (уколико је задат само један улазни вектор онда ће MATLAB аутоматски
    доделити као другу осу вектор редних бројева);
- вектор _y_ са подацима које желимо да исцртамо на вертикалној оси;
    Важне напомене:
       − вектори _x_ и _y_ морају бити исте дужине;
       − ако је задат само један улазни вектор, нпр. _plot(x)_ , функција
          исцртава степенасти графикон елемената вектора _x_ y
          зависности од њиховог редног броја;


7. Исцртавање графикона
− ако су задата два улазна вектора, команда _plot(x,y)_

```
исцртава графикон зависности вектора y од вектора x.
```
- аргумент _‘format_linije’_ служи за дефинисање врсте и боје линије
    којом се исцртавају жељени подаци.

```
Боја линије Врста линије Ознаке података
‘r’ црвена боја ‘-’ пуна линија ‘.’ тачка
‘b’ плава боја ‘--’ испрекидана линија ‘о’ кружић
```
```
‘g’ зелена боја ‘:’ тачкаста линија ‘х’ х
‘k’ црна боја ‘-.’ тачка-цртица линија ‘+’ плусић
‘w’ бела боја ‘*’ звездица
```
```
‘y’ жута боја ‘v’ троугао на доле
‘^’ троугао на горе
```
```
На пример:
− ‘b-’ исцртава пуну линију (-) плаве боје (b);
```
```
− ‘r:’ исцртава тачкасту линију (:) црвене боје (r);
− ‘y--’ исцртава испрекидану линију (--) жуте боје (y);
− ‘g.’ исцртава тачке (.) зелене боје (g);
```
```
− ‘ro’ исцртава кружиће (о) црвене боје (r);
− ‘k*’ исцртава звездице (*) црне боје (k);
```
```
− ‘y+’ исцртава плусиће (+) жуте боје (y).
```
Више информација о могућностима функције _plot_ може се сазнати

коришћењем команде

```
>> help plot
```
Пример 7. 1

Користећи податке из табеле, исцртати линијски график зависности _х_ од _у_.

```
X 2 2, 5 3 3,
Y 3 5 7 9
```
```
>> x = [2 2.5 3 3.5]
```
```
x =
2 2.5 3 3.
```
```
>> y = [3 5 7 9]
```
```
y =
```

7. Исцртавање графикона
3 5 7 9

```
>> plot(x,y)
```
Пример 7. 2

Податке из претходног примера исцртати као дискретни графикон, у оквиру

кога ће свака тачка бити приказана црвеним симболом _x_ дебљине 3.

```
>> plot(x,y,'rx','LineWidth',3)
```
Пример 7.

Исцртати график полинома

```
5 4 3 2
x −  +  −  −  +12 1, x 40 5, x 17 x 71 5, x 35 8, за
```
##### −  1 5, x 6 7,.


7. Исцртавање графикона
>> p = [1 -12.1 40.5 - 17 - 71.5 35.8];
>> x = - 1.5:0.1:6.7;
>> y = polyval(p,x);
>> plot(x,y)
>> xlabel('x')
>> ylabel('y')

**Исцртавање више кривих у оквиру једног графикона**

Коришћењем функције _plot_ могуће је исцртати већи број података у оквиру

једног графикона. Довољан је један позив функције, јер MATLAB аутоматски

кружи по елементима листе боја (коју корисник може прилагодити својим

потребама) да би сваком уређеном пару података доделио другу боју за

приказивање.

Пример 7. 4

Исцртати вредности синусних функција sin t( ), sin t( − 05 , ) и sin t( − (^1) ) за 100
тачака у интервалу [0, 2 ].
>> t = 0:pi/100:2*pi;
>> y1 = sin(t);
>> y2 = sin(t-0.5);
>> y3 = sin(t-1);
>> plot(t,y1,t,y2,t,y3)


7. Исцртавање графикона

Пример 7. 5

###### Нацртати косинусну функцију на интервалу [0,1] пригушену коришћењем

експоненцијалне функције

```
x
```
###### e

```
−
```
. На истом графикону нацртати и овојнице

пригушене косинусне функције. На графикону исписати аналитички облик

пригушене косинусне функције (коришћењем команде _text_ ), а графикон

назвати „Priguseni kosinus” (коришћењем команде _titlе_ ).

Напомена: функција _linespace(x1,x2,n)_ генерише _n_ тачака између _x 1_ и _x 2_.

```
>> x = linspace(0,1,100);
>> y = exp(-x).*cos(6*pi*x);
% iscrtava trazenu funkciju
>> plot(x,y)
% definise ovojnicu funkcije
>> w = exp(-x); z = - w;
% iscrtava trazenu funkciju zajedno sa ovojnicama
>> plot(x,y,'b-',x,w,'r:',x,z,'r:'), title('Priguseni
kosinus')
% ispisuje tekst na grafiku koji pocinje u tacki sa
kordinatama
% (x,y)=( 0 .45, 0 .7)
>> text( 0 .45, 0 .7,'y=exp(-x).*cos(6*pi*x)')
```

7. Исцртавање графикона

**Исцртавање подграфикона**

У MATLAB-у је могуће исцртати више графикона у оквиру једне слике тј.

матрицу графикона коришћењем функције _subplot(m,n,p)_ , где су _m_ и _n_

параметри који означавају број графикона које желимо да исцртамо водоравно

и хоризонтално, док је _p_ позиција тренутног графикона у матрици графикона

величине mn. Пре исцртавања матрице графикона потребно је оформити

нови прозор коришћењем наредбе _figure_.

Пример 7. 6

Исцртати вредности функција из Примера 7. 4 у засебним графиконима у оквиру

матрице графикона величине 31  (један испод другог). Вредности задатих

функција исцртати у различитим бојама, користећи различите типове линија.

```
>> figure
>> subplot(3,1,1);
>> plot(t,y1);
>> subplot(3,1,2);
>> plot(t,y2,'r--');
>> subplot(3,1,3);
>> plot(t,y3,'g-.')
```

7. Исцртавање графикона

**Тродимензионално исцртавање података**

MATLAB подржава и цртање тродимензионалних графикона коришћењем

функције _plot3(x,y,z)_. Потребно је да вектори података _x_ , _y_ и _z_ буду исте

дужине.

Пример 7. 7

Користећи податке из табеле исцртати дискретни тродимензионални график

користећи знак _'о'_ за обележавање података. Поред тога, укључити мрежни

приказ на графикону (команда _grid_ ) како би дијаграм био прегледнији.

```
X 1 2 3 4
Y 1 4 9 16
Z 1 8 27 64
```
```
>> x = [ 1 2 3 4 ]; y = [ 1 4 9 16]; z = [1 8 27 64];
>> plot3(x,y,z,'o','LineWidth',2)
>> grid on
```

7. Исцртавање графикона

**Исцртавање функција**

За разлику од функције _plot_ која исцртавање врши прослеђивањем

конкретних вредности независних и зависних варијабли, функција _fplot_ може

исцртати функцију у задатом домену без прослеђивања појединачних вредности

варијабли.

```
fplot(@(x)funkcija_оd_X, granice, specifikacija_linije)
```
Улазни аргументи функције су:

- први улазни аргумент је функција задата као анонимна функција у
    следећем облику _@(x) sin(x-pi/5)_ ;
       Важне напомене:
          − Аргумент функције коју треба исцртати може бити означен
             било којим словом, на пример: _@(z) 8*z^2+cos(z)_ или _@(t)_
             _8*t^2+5cos(t)_.
- границе домена се задају на следећи начин _[xmin,xmax]_ ;
- спецификација линије се задаје на исти начин као за функцију _plot_ -
    параметрима _‘ime svojstva’_ и _vrednost_svojstva_.

Пример 7. 8

##### Исцртати функцију x^2 +− 4 sin( 2 x) 1 у домену −  2 5, x 2 5,.

```
>> fplot(@(x) x^2+4*sin(2*x)- 1 ,[-2.5,2.5])
```

7. Исцртавање графикона

Пример 7. 9

Графичким путем наћи решење једначине

```
2
```
###### 2

```
x
```
###### =x , односно пронаћи тачке у

којима се секу задате функције.

Урадити следеће:

```
a) Нацртати обе функције на једном графику, обележити осе, означити
функције формулама, нацртати функције различитим бојама;
```
```
б) Написати наслов „Resenje jednacine: zadata_jednacina“, означити тачке у
којима се налазе решења, записати решења у горњем левом углу графика и
уоквирити их.
```
Користити било где на графику бар једном елементе: _arrow_ , _text arrow_ ,

_text box_.

```
>> fplot(@(x) x^2,[1 4.5])
>> hold on
>> fplot(@(x) 2^x,[1 4.5])
>> hold off
```
Након исцртавања графикона, потребно је позвати команду _plottools_ у

оквиру које се график може допунити траженим елементима.


7. Исцртавање графикона

**Специјални графикони**

Поред стандардних линијских, MATLAB омогућава исцртавање података

коришћењем специјалних типова графикона као што су хистограми, дискретни,

степенасти и кружни графикони.

За цртање хистограма користе се функције _bar(x,y)_ и _barh(x,y)_.

Пример 7. 10

У наредној табели дати су подаци о продаји аутомобила у Србији у последњих

пет година. Исцртати податке коришћењем хистограма.

```
Година 2016 2017 2018 2019 2020
Продаја 27.194 28.962 30.730 34.202 26.
```
```
>> god = [2016:2020];
>> pro = [27194,28962,30730,34202,26165];
>> bar(god,pro,'r');
>> xlabel('Godina')
>> ylabel('Prodaja')
```

7. Исцртавање графикона

```
>> barh(god,pro,'r');
>> xlabel('Prodaja')
>> ylabel('Godina')
```
За исцртавање степенастих графикона користи се функција _stairs(x,y)_ , док

се за кружне графиконе користи _pie(x)_.

Пример 7. 11

Коришћењем дискретног и степенастог графикона исцртати вредности

полинома

```
6 4 2
```
##### x −+ 32 x x на интервалу −  1 5, x 1 5,.

```
>> p = [1 0 - 3 0 2 0 0];
>> x = - 1.5:0.05:1.5;
>> subplot(2,1,1);
>> stem(x,polyval(p,x))
>> subplot(2,1,2);
>> stairs(x,polyval(p,x))
```

7. Исцртавање графикона

Пример 7. 12

Коришћењем кружног графикона приказати расподелу студентских оцена из

табеле.

```
Оцена 5 6 7 8 9 10
Број студената 64 23 18 13 11 7
```
```
>> ocene = [ 64 23 18 13 11 7];
>> pie(ocene);
% naziv grafikona
>> title('Ocene studenata');
```

7. Исцртавање графикона

**Задаци за вежбање**

Задатак 7. 1

Користећи податке из табеле исцртати зависност променљивих _x_ и _y_ од

променљиве _t_.

```
T 1 2 3 4
x 1 2 3 4
y 1 4 9 16
```
```
>> t = [1,2,3,4];
>> x = [1,2,3,4];
>> y = [1,4,9,16];
>> plot(t,x,t,y)
```
Задатак 7. 2

###### У два одвојена подграфика исцртати следеће функције у интервалу [ 1,1]− :

− x,

```
2
```
###### x и

```
3
```
###### x у оквиру подграфика 1,

```
−
```
```
1
```
###### x

```
−
,
```
```
2
```
###### x

```
−
и
```
```
3
```
###### x

```
−
у оквиру подграфика 2.
```
```
>> figure
>> subplot(2,1,1)
>> title('podgrafik 1')
>> hold on
>> fplot(@(x) x^1,[-1,1])
>> fplot(@(x) x^2,[-1,1])
>> fplot(@(x) x^3,[-1,1])
>> hold off
```

7. Исцртавање графикона
>> subplot(2,1,2)
>> title('podgrafik 2')
>> hold on
>> fplot(@(x) x^-1,[-1,1])
>> fplot(@(x) x^-2,[-1,1])
>> fplot(@(x) x^-3,[-1,1])
>> hold off

Задатак 7. 3

Учитати податке о IMDB оцени филма, оцени филма од стране публике и буџету

за његово снимање из фајла filmovi.xlsx (доступан на линку

[http://labsys.fon.rs/teorija-sistema/materijali).](http://labsys.fon.rs/teorija-sistema/materijali).) Нацртати зелени хоризонтални бар

график за 10 најбоље оцењених филмова на првом подграфику. На другом,

нацртати график који представља однос оцене са IMBD-a и оцене публике, где

су тачке на графику заправо црне звездице. На њему такође приказати и

апроксимирану криву другог реда ове две колоне зеленом бојом како би се на

лакши начин приказао постојећи тренд. На трећем подграфику приказати однос

оцене са IMBD-a и уложеног новца црвеним кружићима. Приказати и

апроксимирану криву другог реда, која ће бити плава, тачкаста линија дебљине

два. Сваки од графика насловити и означити осе.

```
>> filmovi = xlsread('filmovi.xlsx','Sheet1','B2:D32');
>> prosecnaOcena = round((filmovi(:,1)+filmovi(:,2))/2,2);
>> sortiraniFilmovi = sortrows([prosecnaOcena
filmovi(:,3)], [1 2], {'descend' 'ascend'});
```
```
>> subplot(3,1,1)
>> barh(sortiraniFilmovi(1:10,2),'g')
>> title('10 najuspesnijih filmova')
>> xlabel('Budzet')
>> ylabel('Filmovi')
```

7. Исцртавање графикона

```
>> subplot(3,1,2)
>> plot(filmovi(:,1),filmovi(:,2),'k*')
>> title('Odnos ocena')
>> xlabel('Ocena IMDB')
>> ylabel('Ocena gledaoca')
>> hold on
>> koef = polyfit(filmovi(:,1),filmovi(:,2),2);
>> xp = min(filmovi(:,1)):0.1:max(filmovi(:,1));
>> yp = polyval(koef,xp);
>> plot(xp,yp,'g')
>> hold off
```
```
>> subplot(3,1,3)
>> plot(filmovi(:,1),filmovi(:,3),'ro')
>> hold on
>> koef = polyfit(filmovi(:,1),filmovi(:,3),2);
>> xp = min(filmovi(:,1)):0.1:max(filmovi(:,1));
>> yp = polyval(koef,xp);
>> plot(xp,yp,'b:','LineWidth',2)
>> hold off
>> title('Odnos IMBD ocene i budzeta')
>> ylabel('Budzet')
>> xlabel('IMDB ocena')
```
Задатак 7. 4

Из фајла covid19.xlsx (доступан на линку [http://labsys.fon.rs/teorija-](http://labsys.fon.rs/teorija-)

sistema/materijali) учитати број оболелих људи од вируса по недељама.

Вертикалним тракастим графиконом црвене боје приказати однос оболелих по

недељама. Означити осе и насловити графикон.

```
>> covid 19 = xlsread('covid19.xlsx','Sheet1','A2:B13');
>> bar(covid19(:,1),covid19(:,2),'r')
```

7. Исцртавање графикона
>> xlabel('Nedelja')
>> ylabel('Broj obolelih')
>> title('Broj obolelih u 12 nedelja')

Задатак 7. 5

Графичким путем наћи решење једначине sin( )xx=+^33 односно наћи тачке у

којима се секу две постављене функције. Нацртати обе функције на једном

графику, обележити осе и написати наслов.

```
>> fplot(@(x) sin(x), [-3 3])
>> hold on
>> fplot(@(x) x^3+3, [-3 3])
>> hold off
>> xlabel('x')
>> ylabel('Resenje')
>> title('Resenje jednacine sin(x)=x^3+3')
```

7. Исцртавање графикона


11. Сигнали и карактеристичне функције

###### 11. Сигнали и карактеристичне функције

У уводном делу смо дефинисали информационе процесе као предмет

проучавања теорије система. При аутоматизацији процеса највећи значај

добијају информације о процесу којим се управља. У складу са тим уведен је

појам сигнал као носилац информације. Сигнал је временски променљив

физички феномен који носи неку информацију. Сигнали могу имати веома

различите појавне облике: говорни, звучни, видео, светлосни, електрични

сигнал, итд. Шум је случајни сигнал који не носи информацију. У општем

случају шум је непознат и/или нежељен сигнал јер замагљује информацију.

У зависности од времена у коме посматрамо систем, сигнале можемо поделити

на:

- Континуалне (аналогне) сигнале који су дефинисани у сваком тренутку
    времена на неком временском интервалу,
- Дискретне сигнале који су дефинисани само у одређеним тренуцима
    времена на неком временском интервалу.

На Слици 11.1 континуални сигнал ft() је представљен као функција реалне

променљиве tR , док је дискретан сигнал дефинисан низом вредности

функције fk() у тренуцима kZ.

Често је неопходно да континуалне сигнале апроксимирамо њиховим

дискретним еквивалентом, тако што се у одређеним тренуцима времена узимају

вредности континуaлног сигнала који се називају одбирци, а затим се формира

дискретни сигнал. Овај поступак се назива дискретизација. При томе, кључно је

да се дискретизовани сигнал може реконструисати назад у континуалан сигнал

без губитка информација. Колико често је потребно вршити одабирање

(семпловање) да не би дошло до губљења информација, односно колика је

периода одабирања дефинисано је Шенон-Никвистовом теоремом. Ова теорема

даје услов одабирања изражен преко учестаности одабирача који говори о броју

одбирака у јединици времена.


11. Сигнали и карактеристичне функције

```
Слика 11.1. Дискретизација континуалног сигнала
```
Са настанком потребе за обрадом информација проблем дискретизације

аналогног сигнала постао је један од најзначајнијих проблема за решавање, те

су настале бројне теореме које су покушале да дају одговор колика треба да

буде периода одабаирања. У наставку је дата једна од најпознатијих и

најприхваћенијих Шенон-Никвистова теорема.

**Шенон-Никвистова теорема** : Потребно је да учестаност одабирача s буде

бар два пута већа од граничне учестаности спектра сигнала g:

sg 2 

Пример 11.1 Звучни сигнал за потребе телефонирања ограничен је на

фреквенције мање од 4000 Hz.

Према теореми о одабирању потребно узети бар 8000 Hz, односно 8000

одбирака у секунди (Hsz=1/ ) како би се сигнал могао реконструисати.

Пример 11.2 Ако је учестаност одабирача 10 kHz, колика је максимална

гранична учестаност спектра сигнала који је могуће дискретизовати према

теореми одабирања?


11. Сигнали и карактеристичне функције

Можемо дискретизовати сигнал максималне граничне учестаности 5 kHz.

Пример 11.3 Дат је звучни сигнал f t( ) sin(2 *= g* )t где је g гранична

учестаност једнака 15 Hz. У оквиру једног графикона (на подграфиконима)

приказати како изгледа аналогни сигнал, његов дискретизован еквивалент и

реконструисан сигнал који се добија на основу Шенон-Никвистове теореме.

```
>> clear all
>> t = 0:0.001:1;
>> freq = 15;
>> f = sin(2*pi*freq*t);
>> subplot( 3 , 1 ,1);
>> plot(t,f);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Zvucni signal');
```
```
>> freqS = 30; %ucestanost semplovanja je freqS>=2*freq
>> n = 0:1/freqS:1; %s=1/Hz
>> f1 = sin(2*pi*freq*n);
>> subplot( 3 , 1 , 2 );
>> stem(n,f1);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Semplovan signal na freqS=2*freq');
```
```
>> subplot( 3 , 1 , 3 );
>> plot(n, f1);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Rekonstruisan signal');
```
Пример 11.4 Дат је звучни сигнал f t( ) sin(2 *= g* )t где је g гранична

учестаност једнака 15 Hz. Показати да долази до губљења информација код

реконструисаног сигнала у случају да је учестаност одабирача мања од


11. Сигнали и карактеристичне функције

минималне учестаности према Шенон-Никвистовој теореми (нпр. 10 Hz). Затим

исто поновити у случају да се семпловање врши на 500 Hz. У оквиру једног

графикона (на подграфиконима) приказати како изгледа аналогни сигнал,

његов дискретизован еквивалент и реконструисан.

```
>> clear all
>> t = 0:0.001:1;
>> freq = 15;
>> f = sin(2*pi*freq*t);
>> subplot( 3 , 2 ,1);
>> plot(t,f);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Zvucni signal');
```
```
>> freqS = 1 0; %ucestanost semplovanja je freqS<<2*freq
>> n = 0:1/freqS:1; %s=1/Hz
>> f1 = sin(2*pi*freq*n);
>> subplot( 3 , 2 , 3 );
>> stem(n,f1);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Nedovoljno semplovan signal na freqS<<2*freq');
```
```
>> subplot( 3 , 2 , 4 );
>> plot(n, f1);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Rekonstruisan signal');
```
```
>> freqS = 500; %ucestanost semplovanja je freqS>>2*freq
>> n = 0:1/freqS:1;
>> f1 = sin(2*pi*freq*n);
>> subplot( 3 , 2 , 5 );
>> stem(n,f1);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Previse semplovan signal na freqS<<2*freq');
```
```
>> subplot( 3 , 2 , 6 );
>> plot(n, f1);
>> xlabel('Vreme'); ylabel('Amplituda');
>> title('Rekonstruisan signal');
```

11. Сигнали и карактеристичне функције

**Карактеристични облици сигнала**

У наставку су дати неки од карактеристичних облика сигнала: Хевисајдова и

Диракова функција, Кронекер-делта, правоугаони и троугаони импулс, итд.

Хевисајдова или јединична одскочна функција (Слика 11.2) користи се у

управљању системима као модел прекидача. То је прекидна функција која се

дефинише на следећи начин:

#### ()

1, 0

0, 0

```
t
ht
t
```
```
 
=
 
```
(^0) t
h(t)
1
**Слика 11.2**. Хевисајдова функција
Поред претходне дефиниције, напомињемо да је веома заступљена конвенција
код које разликују три вредности Хевисајдове функције:


11. Сигнали и карактеристичне функције
    1, 0

( ) 1 / 2, 0

0, 0

t

h t t

t

```
 

==
 

```
Претходна конвенција је подразумевана у MATLAB-у приликом коришћења

функције _heaviside_ и биће објашњена у наставку. Напомињемо да у оквиру

курса из Теорије система усвaјамо прву дефиницију према којој Хевисајдова

функција има две вредности: 0 и 1.

У претходном случају tR , односно посматрамо јединичну одскочну функцију у

континуалном времену. У дискретном домену kZ , јединична одскочна

функција се дефинише на следећи начин:

```
1, 0
()
0, 0
```
```
k
hk
k
```
```
 
=
 
```
У оквиру Symbolic Math Toolbox-a омогућен је рад са неколико специјалних

функција које дефинишу карактеристичне облике сигнала. Да бисмо дoбили

вредност Хевисајдове функције за неку нумеричку или симболичку променљиву

_x_ позивамо следећу наредбу:

```
H = heaviside(x)
```
где је подразумевана дефиниција Хевисајдове функције она која враћа

вредности 0 за x0, 1/ 2 за x= 0 и 1 за x0.

```
%numericke promenljive
>> h = heaviside(5)
```
```
h =
1
>> h = heaviside(0)
```
```
h =
0.5000
```
```
%simbolicke promenljive
>> h = heaviside(sym(0))
```
```
h =
1/2
```
```
>> h = heaviside(sym(-5))
```
```
h =
0
```

11. Сигнали и карактеристичне функције

Поред наведене дефиниције могуће је увести дефиницију Хевисајдове функције

која враћа вредности 0 и 1 помоћу функције _sympref_ :

```
>> defaultValues = sympref('HeavisideAtOrigin',1);
>> h = heaviside(0)
```
```
h =
1
```
Пример 11.5 Приказати јединичну одскочну функцију у континуалном времену.

```
>> syms t
>> h=heaviside(t)
```
```
h =
heaviside(t)
```
```
>> fplot(h)
>> ylim([-1 2]);
>> xlabel('t'); ylabel('h(t)');
>> title('Jedinicna odskocna funkcija u kontinualnom
vremenu')
```
Пример 11.6 Нацртати јединичну одскочну функцију у дискретном времену.

```
>> k=- 10 :1: 10 ;
>> h=heaviside(k);
```
```
% probati i sa promenom default vrednosti na 0 i 1
% defaultValues = sympref('HeavisideAtOrigin',1);
```
```
>> stem(k,h);
>> xlabel('k'); ylabel('h(k)');
>> title('Jedinicna odskocna funkcija - diskretan signal');
```

11. Сигнали и карактеристичне функције

Пример 11.7 Приказати јединичну одскочну функцију ht() и њену померену

функцију ht( −2) на интервалу од -10 до 10, a затим и њихову разлику

h t( )−−h t( 2).

```
>> clear all
>> syms t
>> subplot(3,1,1)
>> fplot(heaviside(t),[-10,10])
>> ylim([-1,1.5])
>> xlabel('t'); ylabel('h(t)');
>> subplot(3,1,2)
>> fplot(heaviside(t-2),[-10,10])
>> ylim([-1,1.5])
>> xlabel('t'); ylabel('h(t-2)');
>> subplot(3,1,3)
>> fplot(heaviside(t)-heaviside(t-2),[-10,10])
>> ylim([-1,1.5])
>> xlabel('t'); ylabel('h(t)-h(t-2)');
```

11. Сигнали и карактеристичне функције

Пример 11.8 Приказати функцију f t( )= − −h t( 1) 2* (h t− + −2) h t( 4).

```
>> clear all
>> syms t
>> f=heaviside(t-1)-2*heaviside(t-2)+heaviside(t-4)
```
```
f =
heaviside(t - 1) - 2*heaviside(t - 2) + heaviside(t - 4)
```
```
>> fplot(f)
>> ylim([-1.5 1.5]);
>> xlabel('t'); ylabel('f(t)');
```
Пример 11.9 Показати да је Лапласова трансформација Хевисајдове функције

једнака 1/ .s


11. Сигнали и карактеристичне функције

```
>> syms t
>> h=heaviside(t)
```
```
h =
heaviside(t)
```
```
>> laplace(h)
```
```
ans =
1/s
```
Пример 11. 10 Показати да је Z трансформација Хевисајдове функције једнака

zz/ ( −1).^

```
>> syms k
>> h=heaviside(k)
```
```
h =
heaviside(k)
```
```
>> ztrans(h)
```
```
ans =
1/(z-1) + 1/2
```
```
%postavljamo vrednosti Hevisajdove funkcije na 0 i 1
>> defaultParam = sympref('HeavisideAtOrigin',1);
>> h=heaviside(k);
>> ztrans(h)
```
```
ans =
1/(z-1) + 1
>> sympref('default');
```
Још једна специјална функција је Диракова делта функција (Слика 11.3). Према

својим особинама не испуњава све услове да буде математичка функција у

традиционалном смислу већ се у обради сигнала користи као математички

модел импулса. Представља апроксимацију правоуганика површине један

бесконачно велике амплитуде и бесконачно малог времена трајања те се назива

импулсна функција. Диракова делта функција се дефинише на следећи начин:

#### ()

0, 0

,0

```
t
t
t
```


```
 
=
=
```
###### при чему је (t dt) 1

```

−
```
####  =.^


11. Сигнали и карактеристичне функције

(^0) t
**∞** **_δ_** (t)
**Слика 11.3.** Диракова функција
Потребно је напоменути да постоји веза између претходно наведених функција:
Диракова делта функција је извод јединичне одскочне функције. За практичну
примену ова веза може бити посебно значајна јер се Диракова импулсна
функција тешко може реализовати при решавању практичних инжењерских
проблема те се може користити извод Хевисајдове функције као једноставнији
за реализацију.
Да бисмо добили вредност Диракове делта функције за неку нумеричку или
симболичку променљиву _x_ позивамо следећу наредбу:
_d = dirac(x)_
>> delta = dirac( 0 )
delta =
Inf
>> delta = dirac(sym(5))
delta =
0
Можемо позвати _d = dirac(n,x)_ да бисмо добили извод делта функције, где
је _n_ ред извода делта функције.
Пример 11.11 Показати да важи веза да је   = h t( ) / t ( ).t
>> syms t
>> diff(heaviside(t))
ans =
dirac(t)
Кронекер-делта или квази-делта је дискретни еквивалент Диракове делта
функције. Назива се квази-делта јер узима вредности 1 и 0. Дефинише се у
дискретном домену на следећи начин:


11. Сигнали и карактеристичне функције

#### ( )

1, 0

0, 0

```
k
k
k
```


```
 =
=
 
```
У MATLAB-у вредност квази Диракове функције можемо одредити позивом

следеће наредбе:

```
kroneckerDelta(k)
```
која за прослеђену симболичку променљиву k враћа 1 ако k== 0 и 0 ако је

k~ 0.=

```
>> syms k
>> kroneckerDelta(sym(0)) % prihvata samo simbolicke
promenljive
```
```
ans =
1
```
Пример 11.1 2 Нацртати квази Диракову функцију.

```
>> k = -10:1:10;
>> k_delta = kroneckerDelta(sym(k));
>> stem(k,double(k_delta));
>> xlabel('k'); ylabel('Kroneker-delta(k)');
>> title('Kvazi Dirakova funkcija');
```
Поред наведених издвајају се још неколико специјалних функција као што су

сигнал рампе или нагибни сигнал, сигнум (знак) сигнал, правоугаони и

троугаони импулс, итд.

У MATLAB-у постоји специјална функција за правоуганони импулс:

```
rectangularPulse(a,b,x)
```

11. Сигнали и карактеристичне функције

где _x_ може бити нумеричка или симболичка променљива, _а_ и _b_ горња и доња

граница правоугаоника. Функција правоугаони импулс враћа 1 за _а x b_ ,

затим 1/ 2 за xa= или xb= ,ab , у супротном има вредност 0.

```
>> rectangularPulse(1)
```
```
ans =
0
```
```
% ukoliko se ne navedu granice, podrazumevaju se -1/2 i 1/2
>> rectangularPulse(-1/2,1/2,1)
```
```
ans =
0
```
```
>> rectangularPulse(1/2), rectangularPulse(sym(-1/2))
```
```
ans =
0.5000
```
```
ans =
1/2
```
Пример 11.1 3 Нацртати правоугаони импулс у континуалном времену.

```
>> clear all
>> syms t
>> f=rectangularPulse(-1,1,t)
```
```
f =
rectangularPulse(-1, 1, t)
```
```
>> fplot(f)
>> ylim([-0.5 1.5]);
>> xlabel('t'); ylabel('П(t)');
>> title('Pravougaоni impuls');
```
```
% moze se dobiti i kao razlika dve Hevisajdove funkcije u -
1 i 1
% fplot(heaviside(t+1)-heaviside(t-1))
```

11. Сигнали и карактеристичне функције

Пример 11. 14 Нацртати правоугаони импулс у дискретном времену.

```
>> clear all
>> k=-5:1:5;
>> f=rectangularPulse(-2,2,k);
>> subplot(2,1,1)
>> stem(k,f)
>> xlabel('k'); ylabel('f(k)');
>> title('Pravougaoni impuls u diskretnom vremenu')
```
```
>> defaultParam= sympref('HeavisideAtOrigin',1);
>> f=rectangularPulse(-2,2,k);
>> subplot(2,1,2)
>> stem(k,f)
>> xlabel('k'); ylabel('f(k)');
>> title('Pravougaoni impuls u diskretnom vremenu - 0 i 1')
>> sympref('default'); % vraca parametre na podrazumevane
vrednosti
```

11. Сигнали и карактеристичне функције

Пример 11.1 5 Показати да се Хевисајдова функција (^) ht( −1) може добити као
посебан случај правоугаоног импулса са границама 1,−. Затим на истом
графикону, у оквиру 2 подграфикона, нацртати померену Хевисајдову функцију
ht( −1) као и њену негацију 1 −−ht( 1).
>> clear all
>> syms t
>> f=rectangularPulse(1,inf,t)
f =
heaviside(t - 1)
>> subplot(2,1,1)
>> fplot(f), ylim([-0.5 1.5]), xlabel('t'); ylabel('h(t-
1)');
>> title('Pomerena Hevisajdova funkcija h(t-1)') ;
% jedan nacin je da se negacija dobije kao fplot(1-f)
% negacija h(t-1) ima vrednost 1, od -Inf do trenutka 1
>> f=rectangularPulse(-Inf,1,t)
f =
heaviside(1 - t)
>> subplot(2,1,2)
>> fplot(f), ylim([-0.5 1.5]), xlabel('t'); ylabel('1-h(t-
1)');
>> title('Negacija h(t-1)');
У MATLAB-у постоји специјална функција за троугаони импулс:
_triangularPulse(a,b,c,x)_


11. Сигнали и карактеристичне функције

где _x_ може бити нумеричка или симболичка променљива. За (^) _а x b_  вредност
троугаоног импулса је (x a−−) / (b a), док је за b x c вредност
(c x−−) / (c b), у супротном вредност је 0.
>> triangularPulse(2)
ans =
0
% ukoliko se ne navedu granice, podrazumevaju se - 1 ,0 i 1
>> triangularPulse(-1,0,1,2)
ans =
0
% primetite da za granice a i c vrednost trouganog impulse
je 0
>> triangularPulse(-1,0,1,-1), triangularPulse(-1,0,1,1)
ans =
0
ans =
0
%vrednost za b, simbolicka vrednost
>> triangularPulse(-1,0,1,sym(0))
ans =
1
Пример 11.1 6 Нацртати троугаони импулс у континуалном времену.
>> clear all
>> syms t
>> fplot(triangularPulse(t),[-3,3])
>> ylim([-0.5 1.5]);
>> xlabel('t'); ylabel('f(t)');
>> title('Trougaoni impuls')


11. Сигнали и карактеристичне функције

**Задаци за вежбање**

Задатак 11.1 Показати да је Лапласова трансформација делта функције једнака

1.

```
>> clear all
>> syms t
>> delta = dirac(t)
```
```
delta =
dirac(t)
```
```
>> laplace(delta)
```
```
ans =
1
```
Задатак 11.2 Показати да је Z трансформација квази Диракове функције

једнака 1.

```
>> clear all
>> syms k
>> k_delta = kroneckerDelta(k)
```
```
k_delta =
kroneckerDelta(k,0)
```
```
>> ztrans(k_delta)
```
```
ans =
1
```
Задатак 11.3 Приказати јединичну одскочну функцију ht() и њену померену

функцију ht( +1) на интервалу од - 10 до 10.


11. Сигнали и карактеристичне функције
>> clear all
>> syms t
>> subplot( 2 ,1,1)
>> fplot(heaviside(t),[-10,10])
>> ylim([-1, 2 ])
>> xlabel('t'); ylabel('h(t)');
>> subplot( 2 ,1,2)
>> fplot(heaviside(t+1),[-10,10])
>> ylim([-1, 2 ])
>> xlabel('t'); ylabel('h(t+1)');

Задатак 11. 4 Нацртати троугаони импулс у дискретном времену.

```
>> clear all
>> k=-3:1:3;
>> f=triangularPulse(-2,0,2,k);
>> stem(k,f)
>> xlabel('k'); ylabel('f(k)');
>> title('Trougaoni impuls u diskretnom vremenu')
```

13. Одређивање преносне функције

###### 13. Одређивање преносне функције

У зависности од врсте модела помоћу кога је систем описан, преносну функцију

можемо одредити на више различитих начина.

Ако је систем задат преко У/И описа, преносна функција SISO система има

следећи облик:

```
()
()
()
```
```
Ys
Gs
Us
```
=

за континуалне системе, односно

```
()
()
()
```
```
Yz
Gz
Uz
```
=

за дискретне системе.

У случају У/И описа МIМО система, преносна функција представљена је

матрично на следећи начин:

##### ( )

##### ( ) ( ) ( )

##### ( ) ( ) ( )

##### ( ) ( ) ( )

```
11 12 1
```
```
21 22 2
```
```
12
```
```
r
```
```
pxr r
```
```
p p pr
```
```
G s G s G s
```
```
G s G s G s
Gs
```
```
G s G s G s
```
```


=



```
##### Gsij() повезује j-ти улаз и i-ти излаз, када су сви улази нула, осим j-тог

улаза:

```
0
```
```
()
()
( ) |
```
```
i
ij
j сви улазиосимј тогсу
```
```
Ys
Gs
Us −
```
=

Систем може бити описан преко графа тока сигнала или блок дијаграма. У том

случају преносна функција може се одредити помоћу Мејсоновог правила или

алгебре преносних функција.

Уколико је систем описан преко модела у простору стања (који ће бити

разматран у наредном поглављу) преносна функција може се одредити помоћу

формуле:

( ) ( )

```
1
G s C s I A B D
```
```
−
=   −  +
```

13. Одређивање преносне функције

за континуалне системe, односно

( ) ( )

```
1
G z C z I A B D
```
```
−
=   −  +^
```
у случају дискретних система.

У MАТЛАБ-у, у оквиру Control System Toolbox-а понуђено је више функција за

креирање различитих модела система, у облику преносне функције и описа у

простору стања. За разлику од преносне функције коју смо у претходним

поглављима дефинисали и користили као векторе коефицијената бројиоца и

имениоца или у облику симболичког израза, у Control System Toolbox-у креира

се систем као тип објекта (нпр. _tf_ или _ss_ ). Предност дефинисања модела на

овај начин је могућност директне примене различитих конверзије модела из

једног облика у други (нпр. _tf 2 ss_ ) и осталих специјалних функција које су

специфичне за анализу система (нпр. _size_ или _ctrb_ ), а које су подржане у

оквиру у Control System Toolbox-а.

Функцијом _sys = tf(num,den)_ креирамо преносну функцију у континуалном

времену где је _num_ бројилац (енг. numerator), а _den_ именилац (енг.

denominator). Представљени су помоћу два вектора који садрже коефицијенте

полинома бројиоца односно имениоца.

У случају једноставних система са једним улазом и једним излазом (SISO) _num_ и

_den_ су вектори врсте.

###### Y s( )=G s U s( ) ( )

###### G s( )=s

```
>> Gs = tf([1 0],1) %objekat tipa tf
```
```
Gs =
s
```
```
Continuous-time transfer function.
```
За системе са више улаза и више излаза (MIMO) _num_ и _den_ су вектори врста

чији је број редова једнак броју излаза и/или вектори колона чији је број

колона једнак броју улаза.

Дат је систем са два улаза и једним излазом у облику

##### ( ) ( ) ( )

##### ( )

```
1
12
2
```
```
Us()
Y s G s G s
Us
```
```

    = 

```

13. Одређивање преносне функције

###### Y s( )=+G s U s 1 ( ) 1 ()G s U s 2 ( ) 2 ( )^

Преносна функција се може представити као

### G s( )=G s G s 12 ( ), ( )

Пример 13.1 Систем са два улаза и једним излазом има две преносне функције:

од првог улаза до излаза и од другог улаза до излаза.

```
>> num1=[2,0]; den1=[4,1];
>> num2=[3]; den2=[5,1];
>> Gs1=tf(num1,den1);
>> Gs2=tf(num2,den2);
>> Gs=[Gs1,Gs2]
```
```
Gs =
From input 1 to output:
2 s
-------
4 s + 1
```
```
From input 2 to output:
3
-------
5 s + 1
```
```
Continuous-time transfer function.
```
У случају да преносна функција има облик:

#### ( )

#### ( )

#### ( )

```
1
```
```
2
```
```
Gs
Gs
Gs
```
```

=

```
она одговaра систему са једним улазом и два излаза.

#### ( )

#### ( )

#### ( )

#### ( )

#### ( )

```
1 1
```
(^22)
Ys Gs
Us
Ys Gs

=


### ( ) ( )

### ( ) ( )

```
11
```
```
22
```
()

()

Y s G s U s

Y s G s U s

=

=

Пример 13.2 Систем са једним улазом и два излаза има две преносне функције:

од улаза до првог излаза и од улаза до другог излаза.


13. Одређивање преносне функције

#### ( )

```
2
```
1

```
22
1
```
s

```
ss
Gs
```
s

```
+
++
=


```
```
>> num = {[1 1] ; 1}; den = {[1 2 2] ; [1 0]};
>> Gs = tf(num,den)
```
```
Gs =
From input to output...
s + 1
1: -------------
s^2 + 2 s + 2
```
```
1
2: -
s
```
```
Continuous-time transfer function.
```
```
>> size(Gs) %provera dimenzija sistema
```
```
Transfer function with 2 outputs and 1 inputs.
```
Преносну функцију у дискретном времену креирамо коришћењем наредбе _sys_

_= tf(num,den,Ts)_ са периодом одабирања _Тs_ у секундама (нпр. _Тs = - 1_

или _Тs = []_ када не желимо да дефинишемо специфичну вредност).

Пример 13.3 Дефинисати преносну функцију система у дискретном времену са

периодом одабирања 0.4:

##### ( ) 2

```
0.5
1.5 2
```
```
z
Gz
zz
```
```
+
=
++
```
```
>> numd=[1,0.5]; dend=[1,1.5,2]; Tsd=0.4;
>> Gz=tf(numd,dend,Tsd)
```
```
Gz =
z + 0.5
---------------
z^2 + 1.5 z + 2
```
```
Sample time: 0.4 seconds
Discrete-time transfer function.
```
Преносна функција се може дефинисати као рационални израз по променљивој

_s_ или _z_. Функцијом _s = tf('s')_ креирамо модел преносне функције по


13. Одређивање преносне функције

Лапласовој променљивој _s_ односно са _z = tf('z',Ts)_ креирамо модел

преносне функције по променљивој дискретног времена _z_.

```
>> s = tf('s');
>> Gs = s/(s^2 + 2*s +10);
```
Исто је што и:

```
>> Gs = tf([1 0],[1 2 10]);
```
**Алгебра преносне функције**

Када је систем описан преко графа тока сигнала или блок дијаграма често је

најједноставније да се користи алгебра преносне функције или Мејсоново

правило за одређивање преносне функције система.

Алгебра преносне функције уводи правила за одређивање преносних функција

сложених система. Нека од основних правила односе се на редну, паралелну

везу и повратну спрегу и њихове одговарајуће преносне функције.

Уколико не знамо пуно о систему и његовом понашању, систем представљамо

моделом црне кутије. Међутим, уколико нам је позната преносна функција онда

знамо везу између улаза и излаза, те модел система постаје бела кутија као на

Слици 13.1.

```
Слика 13.1. Преносна функција - позната веза између Uи Y
```
Основно правило блок дијаграма гласи: излазни сигнал је производ преносне

функције у блоку и улазног сигнала. На основу Слике 13.1 добијамо да је:

###### Y s( )=G s U s( ) ( )

Применом основног правила можемо извести и облик преносне функције за

редну, паралелну везу и повратну спрегу. Редна или серијска веза је приказана

на Слици 13. 2 где је дат низ подсистема који су редно (серијски) везани.


13. Одређивање преносне функције

```
Слика 13.2. Редна или серијска веза
```
На основу правила блок дијаграма добија се следећи облик:

```
1 1 2
```
```
1 2 2 1 1 2 2 1
```
( ) ( ) ...

... ...

```
n n n n n
```
```
n n n n n n
```
Y s G Y G G Y

G G G G Y G G G G G U

```
− − −
```
```
− − − −
```
= = = =

==

Дакле, преносна функција која одговара редној вези је облика:

```
12
1
```
## ( ) ( ) ( )... ( ) ( )

```
n
```
```
ni
i
```
## G s G s G s G s G s

```
=
```
# ==

Можемо закључити да преносна функција сложеног система представља

производ преносних функција подсистема који су везани редно.

Паралелна веза је приказана на Слици 13.3 где су представљени подсистеми

који су везани паралелно.

```
Слика 13.3. Паралелна веза
```
Дакле, преносна функција која одговара паралелној вези је облика:

```
12
1
```
## ( ) ( ) ( ) ... ( ) ( )

```
n
ni
i
```
## G s G s G s G s G s

```
=
```
# = + + + =


13. Одређивање преносне функције

Можемо закључити да преносна функција сложеног система представља збир

преносних функција подсистема који су везани паралелно.

Задатак 13.1 На основу правила блок дијаграма извести облик преносне

функције за паралелну везу (Слика 13.3).

Повратна спрега је приказана на Слици 13 .4. Подсетимо се да је систем са

повратном спрегом уколико одзив система зависи не само од улаза већ и од

претходних излаза. Разликујемо позитивну и негативну повратну спрегу у

зависности од тога да ли појачава или смањују улазно дејство које делује на

систем. У управљању системима негативна повратна спрега је посебно важна

јер делује стабилишуће на систем док у рачунарској интелигенцији концепт

повратне спреге се налази у основи алгоритама учења.

```
Слика 13.4. Повратна спрега
```
На Слици 13.4 минус се користи да представи негативну, а плус позитивну

повратну спрегу. Дакле, преносна функција која одговара позитивној/негативној

повратној спрези је облика:

```
()
1
```
```
G
Gs
GH
```
```
=^
```
Задатак 13.2 На основу правила блок дијаграма извести облик преносне

функције за повратну спрегу (Слика 13.4).

У MATLAB-у постоје следеће функције за рад са редном, паралелном везом и

повратном спрегом:

_series()_ одређује^ преносну^ функцију^ сложеног^ система^
када су подсистеми везани редно

_parallel()_ одређује^ преносну^ функцију^ сложеног^ система^
када су подсистеми везани паралелно


13. Одређивање преносне функције

_feedback()_ (^) одређује преносну функцију повратне спреге
Пример 1 3. 4 Систем је представљен следећим преносним функцијама:
12
73
( ) , ( )
( 1)( 2) 5
s
G s G s
s s s s
+
==
+ + +
Одредити преносну функцију сложеног система са:
а) редном везом.
б) паралелном везом.
в) повратном спрегом.
% nule, polovi, pojacanje
>> z=[]; p=[0 - 1 - 2]; k= 7 ; %G1
>> [num1 den1]=zp2tf(z,p,k)
num1 =
0 0 0 7
den1 =
1 3 2 0
>> num2=[1 3 ]; den2=[1 5]; %G 2
% drugi nacin da se unesu prenosne funkcije
% num1=[ 7 ]; den1=[1 3 2 0];
% z2=- 3 ; p2=-5; k2=1;
>> [ns ds]=series(num1, den1, num2, den2) % redna veza
ns =
0 0 0 7 21
ds =
1 8 17 10 0
>> sys1=tf(ns,ds)
sys1 =
7 s + 21
---------------------------
s^4 + 8 s^3 + 17 s^2 + 10 s
Continuous-time transfer function.
>> [np dp]=parallel(num1, den1, num2, den2) % paralelna
veza


13. Одређивање преносне функције

```
np =
1 6 11 13 35
```
```
dp =
1 8 17 10 0
```
```
>> sys2=tf(np,dp)
```
```
sys2 =
s^4 + 6 s^3 + 11 s^2 + 13 s + 35
--------------------------------
s^4 + 8 s^3 + 17 s^2 + 10 s
```
```
Continuous-time transfer function.
```
```
>> [nf df]=feedback(num1, den1, num2, den2,-1) % povratna
sprega, negativna
```
```
nf =
0 0 0 7 35
```
```
df =
1 8 17 17 21
```
```
>> sys3=tf(nf,df)
```
```
sys3 =
7 s + 35
--------------------------------
s^4 + 8 s^3 + 17 s^2 + 17 s + 21
```
```
Continuous-time transfer function.
```
У наставку следи пример који је преузет из књиге са решеним задацима (Gajić &

Lelić, 1996).

Пример 13.5 Коришћењем алгебре преносних функција, одредити преносну

функцију система који је представљен следећим блок дијаграмом:


13. Одређивање преносне функције

```
1 2 3
```
```
12
```
```
52
( ) , ( ) , ( ) 2
( 1)
```
```
5
( ) , ( )
42
```
```
G s G s G s
s s s
```
```
ss
H s H s
ss
```
```
= = =
+
```
```
==
++
```
```
>> % negativna povratna sprega G1,H1
>> [n,d]=feedback([0 0 5],[1 1 0],[1 0],[1 4],-1);
>> % redna veza sa G2
>> [n,d]=series(n,d,[0 2],[1 0]);
>> % paralelna veza sa G3
>> [n,d]=parallel(n,d,[2],[1]);
>> % negativna povratna sprega sa H2
>> [n,d]=feedback(n,d,[5 0],[1 2],-1);
>> tf(n,d)
```
```
ans =
2 s^5 + 14 s^4 + 38 s^3 + 46 s^2 + 60 s + 80
--------------------------------------------
11 s^5 + 57 s^4 + 109 s^3 + 68 s^2 + 200 s
```
```
Continuous-time transfer function
```
Напомена: Алгебру преносне функције је могуће користити за одређивање

преносне функције, када се редна, паралелна веза и повратна спрега могу јасно

издвојити односно када не долази до пресецања сигнала између њих. У

супротном могуће је применити Мејсоново правило.

**Мејсоново правило**

За систем који је описан графом тока сигнала, Мејсоново правило даје везу

између почетног и крајњег чвора на графу чиме одређујемо преносну функцију

система. Да бисмо одредили преносну функцију Мејсоновим правилом


13. Одређивање преносне функције

подразумева се познавање основних појмова из теорије графова, као што су

чвор, грана, путања, затворена путања, итд.

Подсетимо се да грана започиње и завршава се чвором. На графу тока сигнала,

усмерене стрелице представљају једносмерно преношење сигнала од почетног

чвора до завршног чвора, док се назначено деловање назива појачање гране. У

сваки чвор може да улази или излази више грана. Сигнал у чвору одређен је

збиром сигнала свих грана који улазе у тај чвор. Према овом договору могуће је

изоставити сабираче из графова тока сигнала.

Путања је скуп сукцесивно повезаних у истом смеру оријентисаних грана.

Директна путања између два чвора је путања дуж које се сваки чвор јавља само

по једанпут. Затворена путања (петља) је путања која полази и завршава се у

истом чвору, при чему се било који други чвор појављује само једанпут.

Појачање путање је производ појачања свих грана која сачињавају ту путању, а

појачање петље је производ појачања свих грана које сачињавају ту затворену

путању. Везу између било која два чвора на графу даје Мејсоново правило.

## Мејсоново правило гласи: Укупно појачање од улаза u до излза y је

```
1
```
## 1

## ()

```
N
kk
k
```
## G s G

```
=
```
## =

## 

# ^

где је  детерминанта графа (карактеристична функција графа)

```
1
```
## 1 ( 1) 1 1 2 3 ...

```
k
jk j j j
k j j j j
```
#  = − − +G = −  G + G − G +

при чему је:

```
j 1
j
```
# G^ збир појачања свих затворених путања графа,

```
j 2
j
```
# G^ збир производа појачања свих могућих комбинација од по две

```
затворене путање које се међусобно не додирују,
```
```
j 3
j
```
# G^

```
...
```
```
збир производа појачања свих могућих комбинација од по три
затворене путање које се међусобно не додирују,
```
```
итд.
```

13. Одређивање преносне функције

Gk

```
појачање k-те директне путање од улазног до излазног чвора, а N је
број директних путања,
```
k (^) детерминанта дела графа који не додирује k-ту директну путању.
Кажемо да се две петље (затворене путање) не додирују, ако немају заједнички
чвор.
Пример 13.6 Систем је описан графом тока сигнала:
Применом Мејсоновог правила одредити преносну функцију система описаног
графом на слици.
Најпре је потребно у оквиру Current Folder-a направити фајл са екстензијом
.net (на пример _zadatak1.net_ ) и у њега унети све чворове и гране задатог
графа. Граф тока сигнала са слике садржи 7 чворова и 8 грана. Свака грана се
уноси као нови ред, при чему су колоне: 1) редни број гране; 2) почетни чвор
гране; 3) крајњи чвор гране; 4) појачање гране. Пре уноса у фајл, добра пракса
је да се чворови нумеришу у смеру с лева на десно и одозго на доле, мада се то
може урадити и на произвољан начин. Редослед уноса грана није битан, али је
такође добра пракса да се пописују с лева на десно. Стога, опис графа тока
сигнала са слике у .net фајлу је следећи:
1 1 2 1
2 2 3 1/(s+4)
3 3 4 - 1
4 4 2 1/(s+1)
5 3 5 1
6 5 4 - 1
7 5 6 s+1
8 6 7 1
Control System Toolbox не садржи функцију која имплементира Мејсоново
правило, али је оваква функција кориснички дефинисана (Walton, 2021) и јавно


13. Одређивање преносне функције

доступна на сајту MathWorks^1. Како би се функција могла бити позвати, фајл

_mason.m_ најпре треба преузети и снимити у Current Folder.

Функција _mason.m_ као улазне параметре прима три вредности: назив .net

фајла са екстензијом у облику низа карактера, број почетног чвора и број

крајњег чвора. Ова функција враћа две вредности: бројилац и именилац

преносне функције у облику низа карактера. Позивом наредбе _help_ може се

добити детаљан описа ове функције.

```
>> help mason
```
У случају приказаног графа тока сигнала и дефинисаног .net фајла, функција

се може позвати на следећи начин.

```
>> [num,den]=mason('zadatak1.net',1,7)
```
```
num =
((1)*(1/(s+4))*(1)*(s+1)*(1)*(1)-0)
```
```
den =
1 - ((1/(s+4))*(-1)*(1/(s+1))+(1/(s+4))*(1)*(-1)*(1/(s+1)))
```
Као што је раније назначено, добијене променљиве _num_ и _den_ су типа низова

карактера. Како би се могло њима лакше манипулисати и дефинисати преносну

функцију, треба их конвертовати у симболичке променљиве. Даље, преносна

функција се добија као минимални облик количника променљивих _num_ и _den_.

```
>> num = str2sym(num); den = str2sym(den);
>> Gs = simplify(num/den)
```
```
Gs =
(s + 1)^2/(s^2 + 5*s + 6)
```
Пример 13.7 Систем је описан графом тока сигнала:

(^1) https://www.mathworks.com/matlabcentral/fileexchange/22-mason-m


13. Одређивање преносне функције

Применом Мејсоновог правила одредити преносну функцију система описаног

графом на слици.

Граф тока сигнала који описује овај дискретан систем има 7 чворова и 11 грана.

Садржај фајла _zadatak2.net_ , у коме су пописане све гране графа тока сигнала

је:

```
1 1 2 1
2 2 3 - 3
3 3 4 1/z
4 4 5 1/z
5 5 6 1/z
6 6 7 1
7 2 4 2
8 2 5 1
9 6 5 - 6
10 6 4 - 12
11 6 3 - 8
```
Преносна функција се одређује на следећи начин:

```
>> [num,den]=mason('zadatak2.net',1,7);
>> num = str2sym(num); den = str2sym(den);
>> Gz = simplify(num/den)
```
```
Gz =
(z^2 + 2*z - 3)/(z + 2)^3
```
Пример 13.8 Систем је описан графом тока сигнала:

Применом Мејсоновог правила одредити преносну функцију система описаног

графом на слици.

Граф тока сигнала који описује овај континуалан систем има 7 чворова и 11

грана. Садржај фајла _zadatak3.net_ , у коме су пописане све гране графа тока

сигнала је:


13. Одређивање преносне функције
1 1 2 1
2 2 3 1/s
3 3 4 1/s
4 4 5 1/s
5 5 6 1
6 6 7 1
7 3 6 1
8 4 6 - 2
9 3 2 - 4
10 4 2 - 5
11 5 2 - 2

Преносна функција се одређује на следећи начин:

```
>> [num,den]=mason('zadatak3.net',1,7)
```
```
num =
'((((1)*(1/s)*(1/s)*(1/s)*(1)*(1)*(1)-0)+(1)*(1/s)*(1/s)*(-
2)*(1)*(1)-0)+(1)*(1/s)*(1)*(1)*(1)-0)'
```
```
den =
' 1 - ((1/s)*(-4)+(1/s)*(1/s)*(-5)+(1/s)*(1/s)*(1/s)*(-2))'
```
```
>> num = str2sym(num); den = str2sym(den);
>> Gs = simplify(num/den)
```
```
Gs =
(s - 1)^2/((s + 1)^2*(s + 2))
```
```
>> pretty(Gs)
```
```
2
(s - 1)
----------------
2
(s + 1) (s + 2)
```
**Задаци за вежбање**

Задатак 1 3.3 Систем је представљен следећим преносним функцијама:

```
12
```
```
5 4( 1)
( ) , ( )
( 3)( 2) 3
```
```
s
G s G s
s s s s
```
```
+
==
+ + +
```
Одредити преносну функцију сложеног система са:

а) редном везом.

б) паралелном везом.


13. Одређивање преносне функције

в) повратном спрегом.

```
% nule, polovi, pojacanje
>> z=[]; p=[0 - 3 - 2]; k=5;
>> [num1 den1]=zp2tf(z,p,k)
```
```
num1 =
0 0 0 5
```
```
den1 =
1 5 6 0
```
```
>> num2=[ 4 4]; den2=[1 3 ];
```
```
% drugi nacin da se unesu prenosne funkcije
% num1=[5]; den1=[1 3 2 0];
% z2=-4; p2=-5; k2=1;
```
```
>> [ns ds]=series(num1, den1, num2, den2) %redna veza
```
```
ns =
0 0 0 20 20
```
```
ds =
1 8 21 18 0
```
```
>> sys1=tf(ns,ds)
```
```
sys1 =
20 s + 20
---------------------------
s^4 + 8 s^3 + 21 s^2 + 1 8 s
```
```
Continuous-time transfer function.
```
```
>> [np dp]=parallel(num1, den1, num2, den2) % paralelna
veza
```
```
np =
4 24 44 29 15
```
```
dp =
1 8 21 18 0
```
```
>> sys2=tf(np,dp)
```
```
sys2 =
4 s^4 + 24 s^3 + 44 s^2 + 29 s + 15
-----------------------------------
s^4 + 8 s^3 + 21 s^2 + 18 s
```
```
Continuous-time transfer function.
```

13. Одређивање преносне функције
>> [nf df]=feedback(num1, den1, num2, den2,-1) % povratna
sprega, negativna

```
nf =
0 0 0 5 15
```
```
df =
1 8 21 38 20
```
```
>> sys3=tf(nf,df)
```
```
sys3 =
5 s + 15
--------------------------------
s^4 + 8 s^3 + 21 s^2 + 38 s + 20
```
```
Continuous-time transfer function.
```
Задатак 13. 4 Систем је описан графом тока сигнала:

Применом Мејсоновог правила одредити преносну функцију система описаног

графом на слици.

Садржај фајла _zadatak 4 .net_ , у коме су пописане све гране графа тока сигнала

је:

```
1 1 2 1
2 2 3 - 3
3 3 4 1/z
4 4 5 1 /z
5 5 6 1 /z
6 6 7 1
7 2 4 2
8 2 5 1
9 6 5 - 5
10 6 4 - 8
11 6 3 - 4
```

13. Одређивање преносне функције

```
>> [n,d]=mason('zadatak4.net',1,7)
```
```
n =
'((((1)*(-3)*(1/z)*(1/z)*(1/z)*(1)*(1)-
0)+(1)*(2)*(1/z)*(1/z)*(1)*(1)-0)+(1)*(1)*(1/z)*(1)*(1)-0)'
```
```
d =
' 1 - ((1/z)*(1/z)*(1/z)*(-4)+(1/z)*(1/z)*(-8)+(1/z)*(-5))'
```
```
>> n = str2sym(n); d = str2sym(d);
>> >> Gz=simplify(n/d)
```
```
Gz =
(z^2 + 2*z - 3)/((z + 1)*(z + 2)^2)
```
Задатак 13. 5 Систем је описан графом тока сигнала:

Применом Мејсоновог правила одредити преносну функцију система описаног

графом на слици.

Садржај фајла _zadatak 5 .net_ , у коме су пописане све гране графа тока сигнала

је:

```
1 1 2 1
2 2 3 1/(s+a)
3 3 4 - 1
4 3 5 1
5 4 2 1 /(s+b)
6 5 4 - 1
7 5 6 s+b
8 6 7 1
```
```
>> [n,d]=mason('zadatak5.net',1,7)
```
```
n =
'((1)*(1/(s+a))*(1)*(s+b)*(1)*(1)-0)'
```
```
d =
' 1 - ((1/(s+a))*(-1)*(1/(s+b))+(1/(s+a))*(1)*(-
1)*(1/(s+b)))'
```
```
>> n = str2sym(n); d = str2sym(d);
>> Gs=simplify(n/d)
```

13. Одређивање преносне функције

```
Gs =
(b + s)^2/(a*b + a*s + b*s + s^2 + 2)
```
```
>> pretty(Gs)
2
(b + s)
------------------------
2
a b + a s + b s + s + 2
```
Задатак 13. 6 Систем је описан графом тока сигнала:

Применом Мејсоновог правила одредити преноснe функцијe oд улаза u до

излаза y 1 и до излаза y 2 система описаног графом на слици.

Садржај фајла _zadatak 6 _1.net_ , у коме су пописане све гране графа тока

сигнала oд улаза u до излаза y 1 је:

```
1 1 2 1
2 2 3 1/s
3 3 4 1/s
4 4 5 1/s
5 5 6 2
6 6 7 1
7 4 6 1
8 3 2 - (a+4)
9 4 2 - (4*a+3)
10 5 2 - 3*a
```
Садржај фајла _zadatak 6 _2.net_ , у коме су пописане све гране графа тока

сигнала oд улаза u до излаза y 2 је:

```
1 1 2 1
2 2 3 1/s
3 3 4 1 /s
4 4 5 1/s
5 4 6 1
```

13. Одређивање преносне функције
6 5 6 3
7 6 7 1
8 3 2 - (a+4)
9 4 2 - (4*a+3)
10 5 2 - 3*a

>> [num1,den1]=mason('zadatak6_1.net',1,7);
>> [num2,den2]=mason('zadatak6_2.net',1,7);
>> num1=str2sym(num1); den1=str2sym(den1);
>> num2=str2sym(num2); den2=str2sym(den2);
>> Gs1=simplify(num1/den1)

Gs1 =
(s + 2)/((a + s)*(s^2 + 4*s + 3))

>> Gs2=simplify(num2/den2)

Gs2 =
1/((a + s)*(s + 1))


14. Mодел у простору стања

###### 14. Mодел у простору стања

Како би из улазно-излазног описа превели систем у модел у простору стања

потребно је да одредимо стање система. Избор стања система можемо вршити

коришћењем особине сагласности стања и коришћењем блок дијаграма где

излазе из интегратора односно блокова јединичног кашњења усвајамо за стања

система. Избор стања није једнозначан поступак, па једном У/И опису могу

одговарати више модела у простору стања.

Стање је сажета представа претходних понашања система, довољно потпуна да

нам омогући да на основу улазних дејстава тачно предвидимо какав ће бити

излаз и промене самог стања. Увођењем додатног параметра имамо богатији

опис система. За разлику од У/И описа који даје одзив само за нулте почетне

услове, опис у простору стања може да одреди одзив за било које почетне

услове.

Општи облик модела у простору стања (енг. state space model) у временском

домену чине:

## () ( () ())

## () ( ( ) ())

,,

,,

x t f t x t u t

y t  t x t u t

=

=

где је x вектор стања, u вектор улаза, y вектор излаза. Динамичка једначина

f представља једначину прелаза стања док је (^)  једначина излаза.
Уколико је систем линеаран, модела у простору стања можемо записати
матрично:

#### () ( ) ( ) ( ) ( )

#### () () ( ) ( ) ()

```
dx
x t A t x t B t u t
dt
```
y t C t x t D t u t

= =  + 

=  + 

###### Матрица A описује интерно понашање система, док матрице BC, и D

представљају везе између система и екстерног окружења. Уколико не постоји

директна веза између улаза и излаза, матрица D једнака је нули и излаз зависи

само од времена (^) t и стања xt().

###### Уколико је систем линеаран и стационаран, матрице A B C,, и D имају

константне коефицијенте:


14. Mодел у простору стања

#### ( ) () ( )

#### ( ) () ()

x t A x t B u t

y t C x t D u t

=  + 

=  + 

У MATLAB-у функцијом _sys = ss(A,B,C,D)_ креирамо модел у простору стања

у континуалном времену.

Пример 14.1 Дат је модел система у простору стања другог реда са једним

улазом и једним излазом.

```
1
```
```
1 2
```
```
2
```
```
2
```
```
1
```
4 2 2

y x

```
x x u
dt
```
dx

```
x
dt
```
dx

=

=− − −

=

```
>> A=[0,1;-4,-2]; B=[0;-2]; C=[1,0]; D=[0];
>> ss1=ss(A,B,C,D)
```
```
ss1 =
```
```
A =
x1 x2
x1 0 1
x2 - 4 - 2
```
```
B =
u1
x1 0
x2 - 2
```
```
C =
x1 x2
y1 1 0
```
```
D =
u1
y1 0
```
```
Continuous-time state-space model.
```
При чему су _A, B, C_ и _D_ подразумевани називи променљивих и користе се за

приказ, али их нема посебно забележених у радној меморији тј. њима се

приступа преко структуре променљиве _ss1_.

Општи облик модела у простору стања за систем у дискретном домену је:


14. Mодел у простору стања

## ( ) ( ( ) ( ))

## ( ) ( ( ) ( ))

1 , ,

,,

x n f n x n u n

y n  n x n u n

+=

=

За линеаран дискретан систем, модел у простору стања можемо записати

мaтрично:

#### ( ) ( ) ( ) ( ) ( )

#### ( ) ( ) ( ) ( ) ( )

xn 1 _А n x n B n u n_

y n C n x n D n u n

+ =  + 

=  + 

По аналогији са континуалним системима, линеаран стационаран систем у

дискретном времену је:

#### ( ) ( ) ( )

#### ( ) ( ) ( )

x n 1 A x n B u n

y n C x n D u n

+ =  + 

=  + 

Функцијом _sys = ss(А,B,C,D,Ts)_ креирамо модел у простору стања у

дискретном времену.

Пример 14.2 Дат је модел у простору стања са једним улазом, два излаза и два

стања

### ( ) ( ) ( )

### ( ) ( )

### ( ) ( )

### ( ) ( )

```
11
```
```
22
```
```
11
```
```
22
```
1

1

x n x n u n

x n x n

y n x n

y n x n

+ = − +

+ = −

=

=

```
>> A = [-1 0; 0 -1]; B = [1 ; 0]; C = eye(2); D = zeros(2,
1);
>> sys = ss(A, B, C, D, 0.4)
```
```
sys =
```
```
A =
x1 x2
x1 -1 0
x2 0 - 1
```
```
B =
u1
x1 1
x2 0
```

14. Mодел у простору стања
C =
x1 x2
y1 1 0
y2 0 1

```
D =
u1
y1 0
y2 0
```
```
Sample time: 0.4 seconds
Discrete-time state-space model.
```
```
>> sys.A
```
```
ans =
```
- 1 0
0 - 1

Веза модела у простору стања и преносне функције

Преносну функцију за линеаран стационаран систем описан преко модела у

###### простору стања можемо добити на основу матрице A B C,, и D из следеће

релације:

### ( ) ( )

```
1
G s C s I А B D
```
```
−
=   −  +
```
за континуалне системе, односно

### ( ) ( )

```
1
G z C z I A B D
```
```
−
=   −  +
```
за дискретне системе.

Напомена: Превођења преносне функције као У/И опис система, у опис у

простору стања није једнозначно. У зависности од избора стања, једној

преносној функцији може да одговара више модела у простору стања односно

постоји бесконачан број модела у простору стања којима одговара иста

преносна функција.

**Превођење модела система**

У оквиру Control System Toolbox-a можемо дефинисати различите моделе

система коришћењем:

_tf()_
креира преносну функцију (енг. transfer function) или преводи


14. Mодел у простору стања
модел у простору стања у модел у облику преносне функције;

_ss()_ креира модел у простору стања^ или преводи модел дат преносном
функцијом у модел у простору стања.

Као што је раније наведено, Control System Toolbox служи за рад над

линеарним, временски инваријантних системима. Омогућене су конверзије

између различитих врста модела система (Слика 14.1):

_ss2tf()_ креира преносну функцију преко дате репрезентације^ модела^ у
простору стања

_tf2ss()_ (^) креира модел у простору стања за дату преносну функцију
_tf2zp()_ креира преносну функцију у факторизованом облику израженом
преко нула и полова
_ss2zp()_ креира преносну функцију у факторизованом облику (израженом
преко нула и полова) за дати модел у простору стања
_c2d()_ (^) преводи континуалан систем у дискретан
_d2c()_ (^) преводи дискретан систем у континуалан
_size()_ (^) приказује број излаза и улаза система
**Слика 1 4. 1.** Постојеће функције за конверзију модела


14. Mодел у простору стања

Најчешће преводимо из У/И описа у модел у простору стања, тј. користимо

функције:

_sys = tf(sys)_ како би превeли модел у простору стања у облик преносне

функције.

_sys = ss(sys)_ како би превeли преносну функцију у модел у простору

стања.

Пример 1 4.3 Дат је модел у простору стања:

```
2 1 1 1
[1 0] [0 1]
1 2 2 1
```
_А B C D_

```
−−  
=  =  = =
 −−  
```
Одредити преносну функцију система.

```
>> A = [- 2 - 1;1 -2];
>> B = [1 1;2 -1];
>> C = [1 0];
>> D = [0 1];
>> sys = ss(A,B,C,D);
>> tf(sys)
```
```
ans =
From input 1 to output:
s
-------------
s^2 + 4 s + 5
```
```
From input 2 to output:
s^2 + 5 s + 8
-------------
s^2 + 4 s + 5
```
```
Continuous-time transfer function.
```
Функција _tf_ у овом случају даје једноставан приказ преносних функција,

међутим, ако желимо коефицијенте преносних функција, користимо функцију

_ss2tf_. Последњи аргумент функције је редни број улаза на који се преносна

функција односи.

```
>> [num den] = ss2tf(A,B,C,D,1)
```
```
num =
0 1 0
```
```
den =
1 4 5
```
```
>> [num den] = ss2tf(A,B,C,D,2)
```

14. Mодел у простору стања

```
num =
1 5 8
```
```
den =
1 4 5
```
Пример 14. 4 Дат је модел у простору стања

```
0 1 0
[1 0]
6 5 1
```
_А B C_

```
   
=  =  =
−−  
```
Одредити преносну функцију система.

```
>> A = [0 1;- 6 - 5];
>> B = [0; 1];
>> C = [1 0];
>> D = 0;
>> sys = ss(A,B,C,D); tf(sys)
```
```
ans =
1
-------------
s^2 + 5 s + 6
```
```
Continuous-time transfer function.
```
```
>> [num den] = ss2tf(A,B,C,D)
```
```
num =
0 0 1
```
```
den =
1.0000 5.0000 6.0000
```
Да би се преноснa функција изразила у факторизованом облику (изражено

преко нула и полова) користи се функција _tf2zp_ чији су аргументи бројилац и

именилац преносне функције.

```
>> [z p k] = tf2zp(num,den)
```
```
z =
0×1 empty double column vector
```
```
p =
```
- 3.0000
- 2.0000

```
k =
1
```

14. Mодел у простору стања

Да би се преноснa функцијa представила у факторизованом облику (изражено

преко нула и полова) за дати модел у простору стања користи се функција

_ss2zp_.

```
>> [z p k] = ss2zp(A,B,C,D)
```
```
z =
0×1 empty double column vector
```
```
p =
```
- 2.0000
- 3.0000

```
k =
1
```
Када је преносна функција задата као симболички израз, коришћењем _tf2ss_

може се превести у модел у простору стања:

```
>> [A B C D] = tf2ss(num, den)
```
```
A =
```
- 5.0000 - 6.0000
1.0000 0

```
B=
1
0
```
```
C=
0 1
```
```
D=
0
```
Напомена: Као резултат функције _tf2ss_ добија се једна од познатих

реализација модела у простору стања која се назива управљива каноничка

форма, уколико таква реализација постоји за посматрани систем.

Пример 14.5 Дата је преносна функција MIMO система:

```
32
```
```
2
```
```
2
```
1

```
3 3 2
()
3
```
1

s

```
s s s
Gs
s
```
ss

```
+
+ + +
=
+
++
```
Колико има улаза, а колико излаза овај систем?


14. Mодел у простору стања

Овај систем има један улаз и два излаза.

```
>> Gs = [tf([1 1],[1 3 3 2]); tf([1 0 3],[1 1 1])];
>> sys = ss(Gs);
>> size(sys)
```
```
State-space model with 2 outputs, 1 input, and 5 states.
```
Елементима система тј. матрицама се приступа као структури:

```
>> sys.a
```
```
ans =
```
- 3.0000 - 1.5000 - 1.0000 0 0
    2.0000 0 0 0 0
       0 1.0000 0 0 0
       0 0 0 - 1.0000 - 1.0000
       0 0 0 1.0000 0

Превођење преносне функције у модел у простору стања помоћу функције _ss_

није једнозначно јер може постојати бесконачан број модела у простору стања

којима одговара иста преносна функција. Познате репрезентације модела у

простору стања су управљива, осмотрива, дијагонална и Јорданова каноничка

форма. Функцијом _ss_ бира се само једна таква реализација. Из тог разлога

препоручљиво је избегавати конверзије из једног облика у други више пута

узастопно.

```
sysd = c2d(sys,Ts,method) преводи континуалан у дискретан систем
```
_sysc = d2c(sysd,method)_ преводи дискретан у континуалан систем

Најчешће се користе следеће мeтоде дискретизације:

- Задршка нултог реда (метода правоугаоника) - ' _zoh_ ' (енг. zero-order hold)
- Задршка првог реда (метода трапеза) - ' _foh_ ' (енг. first-order hold _)_

###### Метода ' zoh ' је подразумевана и генерише континуални улазни сигнал ut()

###### памтећи сваку вредност одсечка uk[] у току једног временског периода. Метода

' _foh_ ' користи линеарну интерполацију и не може се користити приликом

конверзије _d2c_.

Пример 14.6 Дискретизовати континуални систем описан преносном функцијом:


14. Mодел у простору стања

```
2
```
```
1
()
45
```
```
s
Gs
ss
```
```
−
=
++
```
Приказати одзиве система континуалног и дискретизованог система ако на

систем делује јединична одскочна, а затим и Диракова импулсна побуда.

```
>> Gs = tf([1 -1],[1 4 5])
```
```
Gs =
s - 1
-------------
s^2 + 4 s + 5
```
```
Continuous-time transfer function.
```
```
>> Gz = c2d(Gs,0.1,'foh')
```
```
Gz =
0.04226 z^2 - 0.01093 z - 0.03954
---------------------------------
z^2 - 1.629 z + 0.6703
```
```
Sample time: 0.1 seconds
Discrete-time transfer function.
```
```
>> step(Gs,Gz)
```
```
>> impulse(Gs,Gz)
```

14. Mодел у простору стања

**Задаци за вежбање**

Задатак 14.1 Систем је описан моделом у простору стања:

###  

-8 -19 -12 1

( ) 1 0 0 ( ) 0 ( )

0 1 0 0

( ) 1 2 0 ( )

x t x t u t

y t x t

```
   
   
=+
   
    
```
=

Наћи преносну функцију система.

```
>> A = [- 8 - 19 - 12; 1 0 0; 0 1 0];
>> B = [1; 0; 0];
>> C = [1 2 0];
>> syms s
>> Gs = C*inv(s*eye(3)-A)*B
```
```
Gs =
(2*s)/(s^3 + 8*s^2 + 19*s + 12) + s^2/(s^3 + 8*s^2 + 19*s +
12)
```
```
>> Gs = simplify(Gs)
```
```
Gs =
(s*(s + 2))/(s^3 + 8*s^2 + 19*s + 12)
```

14. Mодел у простору стања

Задатак 14. 2 Систем је описан моделом у простору стања:

###  

-1 0 1 1

( ) -2 -1 0 ( ) -1 ( )

0 -1 -4 0

( ) 1 0 0 ( )

x t x t u t

y t x t

```
   
   
=+
   
    
```
=

Наћи преносну функцију система.

```
>> A = [-1 0 1; - 2 - 1 0; 0 - 1 - 4];
>> B = [1; -1; 0];
>> C = [1 0 0];
>> sys=ss(A,B,C,[0]);
>> sys=tf(sys)
```
```
sys =
s^2 + 5 s + 5
---------------------
s^3 + 6 s^2 + 9 s + 2
```
```
Continuous-time transfer function.
```
Задатак 1 4. 3 Систем је описан моделом у простору стања:

###  

-2 -1.25 -0.25 1

( 1) 1 0 0 ( ) 0 ( )

0 1 0 0

( ) 1 5 6 ( )

x n x n u n

y n x n

   

```
+ =   + 
   
    
```
=

Наћи преносну функцију система.

```
>> A = [- 2 - 1.25 -0.25; 1 0 0; 0 1 0];
>> B = [1; 0; 0];
>> C = [1 5 6];
>> [n d]=ss2tf(A,B,C,[0])
```
```
n =
0 1.0000 5.0000 6.0000
```
```
d =
1.0000 2.0000 1.2500 0.2500
```
```
>> tf(n,d,-1)
```

14. Mодел у простору стања
ans =
z^2 + 5 z + 6
---------------------------
z^3 + 2 z^2 + 1.25 z + 0.25

```
Sample time: unspecified
Discrete-time transfer function.
```
Задатак 1 4. 4 Систем је описан моделом у простору стања:

###  

-4 -5 -2 1

( ) 1 0 0 ( ) 0 ( )

0 1 0 0

( ) 1 -2 1 ( )

x t x t u t

y t x t

```
   
   
=+
   
    
```
=

а) Наћи преносну функцију система.

б) Дискретизуј модел система описан преносном функцијом за периоду

одабирања Т=0.2s.

```
>> A = [- 4 - 5 - 2; 1 0 0; 0 1 0];
>> B=[1; 0; 0];
>> C=[1 -2 1];
>> [n d]=ss2tf(A,B,C,[0])
```
```
n =
```
```
0 1.0000 -2.0000 1.0000
d =
```
```
1.0000 4.0000 5.0000 2.0000
```
```
>> Gs=tf(n,d)
```
```
Gs =
```
```
s^2 - 2 s + 1
---------------------
s^3 + 4 s^2 + 5 s + 2
```
```
Continuous-time transfer function.
```
```
>> Gz=c2d(Gs,0.2,'foh')
```
```
Gz =
0.06602 z^3 - 0.1169 z^2 - 0.009942 z + 0.06624
-----------------------------------------------
z^3 - 2.308 z^2 + 1.768 z - 0.4493
```

14. Mодел у простору стања
Sample time: 0.2 seconds
Discrete-time transfer function

Задатак 1 4. 5 Систем је описан моделом у простору стања:

###  

3 6 7 0

( ) 0 -1 0 ( ) 0 ( )

-1 0 0 1

( ) -3 1 -2 ( )

x t x t u t

y t x t

```
   
   
=+
   
    
```
=

а) Наћи преносну функцију система.

б) Дискретизуј модел система описан преносном функцијом за периоду

одабирања Т=0. 5 s.

```
>> A=[3 6 7; 0 -1 0; -1 0 0];
>> B=[0; 0; 1];
>> C=[-3 1 -2];
>> [n d]=ss2tf(A,B,C,[0])
```
```
n =
0 - 2 - 17 - 15
```
```
d =
1.0000 -2.0000 4.0000 7.0000
```
```
>> Gs=tf(n,d)
```
```
Gs =
```
- 2 s^2 - 17 s - 15
---------------------
s^3 - 2 s^2 + 4 s + 7

```
Continuous-time transfer function.
```
```
>> Gz=c2d(Gs,0.5,'zoh')
```
```
Gz =
```
- 4.534 z^2 - 0.2646 z + 1.828
--------------------------------
z^3 - 2.566 z^2 + 5.67 z - 2.718

```
Sample time: 0.5 seconds
Discrete-time transfer function.
```

15. Особине модела система

###### 15. Особине модела система

При анализи система потребно је испитати опште карактеристике модела

система које су посебно важне са аспекта пројектовања и примене система:

управљивост, достижљивост, осмотривост и стабилност.

Управљивост (енг. controllability) и достижљивост (енг. reachability) служе као

провера да ли је систем добро направљен јер нам је кључно да можемо да

управљамо системом односно да можемо систем превести из било ког стања у

стање мировања и обрнуто. Често се у литератури под управљивошћу уједно

подразумева и достижљивост. Особина осмотривости (енг. оbservabillity) нам

омогућава да увек знамо стање у коме се систем налази на основу излаза.

Свакако најважнија особина је стабилност (енг. stability) система јер представља

основни предуслов за практичне примене.

**Особина управљивости**

У случају да се посматра линеаран, временски инваријантан систем описан

моделом у простору стања, његова управљивост се одређује помоћу следећег

критеријума:

###### LTI систем описан матрицама A B C,, реда n је управљив акко матрица

управљивости има ранг n, при чему се матрица управљивости формира на

основу матрица A и B:

```
rang B AB... A Bn−^1 =n
^
```
Детаљније објашњење можете видети у (Petrović, 1998).

Пример 1 5 .1 Испитати управљивост система описаног моделом у простору

стања:

```
1 1 1 1 1 0
0
4 2 1 1 0 1
```
_А B C D_

```
   −  
=  =  =  =
 −−    
```
Матрица управљивости се добија позивом функције _ctrb_. Улазни аргументи ове

функције треба да буду матрице A и B.

```
>> A = [1 1; 4 -2];
>> B = [1 -1; 1 -1];
>> C = [1 0; 0 1];
>> D = 0;
```

15. Особине модела система
>> matricaUpravljivosti = ctrb(A, B)

```
matricaUpravljivosti =
```
```
1 - 1 2 - 2
1 - 1 2 - 2
```
```
>> brNeupravljivihStanja = length(A)-
rank(matricaUpravljivosti)
```
```
brNeupravljivihStanja =
```
```
1
```
Пошто је разлика димензије матрице и ранга матрице управљивости једнакa 1,

може се закључити да дати модел има 1 неуправљиво стање и стога није

управљив.

Пример 15. 2 Испитати управљивост система описаног моделом у простору

стања:

(^)  
1 2 1
2 2 1 2
12
( 1) ( ) ( )
( 1) ( ) 2 ( ) ( )
( ) 2 ( ) 4 ( )
x n x n u n
x n x n u n u n
y n x n x n
+ = +
+ = +  +
=  + 
>> A = [0 1; 0 1];
>> B = [1 0; 2 2];
>> C = [2 4];
>> D = 0;
>> matricaUpravljivosti = ctrb(A, B)
matricaUpravljivosti =
1 0 2 2
2 2 2 2
>> brNeupravljivihStanja = length(A)-
rank(matricaUpravljivosti)
brNeupravljivihStanja =
0
**Особина осмотривости**
У случају да се посматра линеаран, временски инваријантан систем описан
моделом у простору стања, његова oсмотривост се одређује помоћу следећег
критеријума:


15. Особине модела система

LTI систем описан матрицама A B C,, реда n је осмотрив акко матрица

осмотривости има ранг n, при чему се матрица управљивости формира на

основу матрица A и C:

```
n 1
```
C

```
CA
rang n
```
CA−

```


=



```
Детаљније објашњење можете видети у (Petrović, 1998).

Пример 15. 3 Испитати осмотривост система описаног моделом у простору

стања:

```
1 1 1 1 1 0
0
4 2 1 1 0 1
```
_А B C D_

```
   −  
=  =  =  =
 −−    
```
Матрица осмотривости се добија позивом функције _obsv_. Улазни аргументи ове

функције треба да буду матрице A и C.

```
>> A = [ 1 1; 4 - 2 ];
>> B = [1 - 1 ; 1 - 1 ];
>> C = [ 1 0; 0 1];
>> D = 0;
```
```
>> matricaOsmotrivosti = obsv(A, C)
matricaOsmotrivosti =
```
```
1 0
0 1
1 1
4 - 2
```
```
>> brNeosmotrivihStanja = length(A)-
rank(matricaOsmotrivosti)
```
```
brNeosmotrivihStanja =
0
```
Разлика димензије матрице и ранга матрице осмотривости је једнака 0, што

показује да је посматрани систем осмотрив.

Пример 15. 4 Испитати осмотривост система описаног моделом у простору

стања:


15. Особине модела система

```
1 1 2 1
```
```
2 1 2
```
```
12
```
( 1) ( ) 2 ( ) ( )

( 1) 3 ( ) 4 ( )

( ) ( ) 2 ( )

x n x n x n u n

x n x n x n

y n x n x n

+ = −  +

+ = −  − 

= + 

```
>> A = [ 1 - 2 ; - 3 - 4 ];
>> B = [1; 0 ];
>> C = [ 1 2 ];
>> D = 0;
```
```
>> matricaOsmotrivosti = obsv(A, C)
```
```
matricaOsmotrivosti =
1 2
```
- 5 - 10

```
>> brNeosmotrivihStanja = length(A)-
rank(matricaOsmotrivosti)
```
```
brNeosmotrivihStanja =
1
```
**Особина стабилности**

У претходним разматрањима подразумевали смо да је систем стабилан односно

да у току свога рада систем није осетљив на случајне поремећаје који на њега

делују. Интуитивно, уколико се након престанка деловања поремећаја, систем

врати у равнотежно стање из којег је изведен онда је стабилан.

На Слици 15 .1 су приказана најједноставнија два случаја. Први случај можемо

посматрати као куглицу која се налази у чаши. Након деловања улазног

дејства, куглица осцилује и тежи да се врати у првобитан положај. У другом

случају, можемо да кажемо да се куглица налази на врху брда. Довољан је мали

поремећај да би се систем извео из равнотежног положаја, те закључујемо да

систем није стабилан. Детаљније објашњење можете видети у (Petrović, 1998).

```
Слика 15.1. Стабилно и нестабилно равнотежно стање
```
Претходно описана асимптотска стабилност посматра понашање система на

основу равнотежног стања односно описује унутрашњост система. Поред тога,


15. Особине модела система

стабилност можемо посматрати на основу улаза и излаа - ОУОИ (енг. BIBO)

стабилност. Систем у мировању је ОУОИ стабилан ако и само ако се при

деловању било ког ограниченог улаза добија ограничен излаз.

Стабилности система можемо сагледати на основу одзива система на

карактеристичне побуде које моделују поремећаје који се могу јавити при раду

система, као што су Хевисајдова и Диракова функција. Као што је приказано на

Слици 15.2, разликујемо прелазни одзив или режим (енг. transient response) и

устаљени одзив (енг. steady state response).

```
Слика 15.2. Приказ прелазног и устаљеног одзива
```
Прелазни одзив траје од почетка деловања побуде до тренутка када одзив

почиње да буде устаљен, након чега систем улази у стационарно стање. Систем

је стабилан уколико се врати у равнотежно стање након престанка деловања

поремећаја и завршетка прелазног режима.

Пример 1 5 .5 На основу одзива система на јединичну одскочну функцију

анализирати стабилност система описаног преносном функцијом

```
2
```
```
1
()
5 16
```
```
s
Gs
ss
```
```
+
=
++
```
.

```
>> num = [1 1]; den = [1 5 16];
>> Gs = tf(num,den);
>> t = 0:0.1:5;
>> step(Gs)
```

15. Особине модела система

Након престанка деловања јединичне одскочне функције и завршетка прелазног

процеса систем је прешао у стационарно стање, те закључујемо да је стабилан.

Пример 1 5 .6 На основу одзива система на јединичну одскочну функцију

анализирати стабилност система описаног преносном функцијом

```
2
```
```
1
()
2
```
```
s
Gs
ss
```
```
+
=
−−
```
```
.
```
```
>> num = [1 1]; den = [1 - 1 - 2];
>> t = 0:0.1:5;
>> step(num,den,t)
```
Систем није прешао у стационарно стање, те закључујемо да није стабилан.


15. Особине модела система

Kритеријуми за испитивање асимптотске и ОУОИ стабилности у континуалном

времену

Асимптотска стабилност LTI система у континулном времену може се испитати

на основу:

- сопствених вредности матрице A
- Рут-Хурвицовог (енг. Routh-Hurwitz),

док се ОУОИ стабилност испитује на основу:

- полова преносне функције.

У наставку су наведени критеријуми за испитивање асимптотске, а затим и

ОУОИ стабилности за временски континуалне LTI системе.

Временски **континуалан** LTI систем је **асимптотски стабилан** ако и само ако

све сопствене вредности матрице A имају негативне реалне делове односно

леже у левој полуравни.

Пример 15 .7 Испитати асимптотску стабилности временски континуалног

система описаног моделом у простору стања на основу сопствених вредности.

####  

```
1 1 1
1 1 0
4 5 0
```
A B C D

```
−   
=  =  = =
−−  
```
```
>> А = [-1 1; - 4 - 5];
>> sv = eig(А)
```
```
sv =
```
- 3.0000 + 0.0000i
- 3.0000 - 0.0000i

Пошто све сопствене вредности задатог временски континуалног система имају

негативне реалне делове, може се закључити да је систем асимптотски

стабилан.

Сопствене вредности се могу одредити решавањем карактеристичне једначине:

```
>> syms s
>> jd = det(s*eye(2)-A)
```
```
jd =
s^2 + 6*s + 9
```
```
>> solve(jd)
```

15. Особине модела система
ans =
- 3
- 3

Уколико је карактеристична једначина превише комплексна за решавање,

стабилност се може испитати на основу Рут-Хурвицовог критеријума. За

карактеристични полином:

```
1
( ) 1 ... 1 0
nn
D s a snna s a s a
−
= + − + + +
```
потребни услови су да су сви коефицијенти карактеристичног полинома истог

знака и да морају бити различити од нуле. У том случају могуће је формирати

одговарајућу Рут-ову шему која има следећи облик:

```
1 2 3 4 1 0
```
```
n
```
```
n
```
```
n
```
```
n
```
```
n
```
```
s s s s s s s
−
```
```
−
```
```
−
```
```
−
```
```
2 4 6
```
```
1 3 5 7
```
```
1 2 3
```
```
1 2 3
```
```
n n n n
```
```
n n n n
```
a a a a

a a a a

b b b

c c c

```
− − −
```
```
− − − −
```
Рут-Хурвицов критеријум: Систем је стабилан ако и само ако су сви елементи

прве колоне Рут-ове шеме истог знака.

Control System Toolbox не садржи уграђену функцију која формира Рут-ову

шему, али је оваква функција кориснички дефинисана (Rivera-Santos, 2021 ) и

јавно доступна на сајту MathWorks^2. Како би се функција могла позвати, фајл

_routh.m_ најпре треба преузети и снимити у Current Folder.

Функција _routh.m_ као улазне параметре прима две вредности:

карактеристичну једначину задату као полином и симболичку променљиву

епсилон. Уколико се при израчунавању матрице јави нула елемент, мења се са

епсилон да би се у наставку избегло дељење са нулом. Позивом наредбе _help_

може се добити детаљан опис ове функције.

```
>> help routh
```
(^2) https://www.mathworks.com/matlabcentral/fileexchange/58-routh-m


15. Особине модела система

Позивом функције _routh_ добијамо Рут-ову матрицу на основу које се закључује

о стабилност система.

Пример 15 .8 Испитати стабилности временски континуалног система описаног

моделом у простору стања на основу Рут-Хурвицовог критеријума.

####  

```
1 1 1
1 1 0
4 5 0
```
B C D

```
−   
=  =  = =
−−  
```
```
>> % preko Rut-Hurviceve seme
>> syms lambda, eps
>> p = det(lambda*eye(2)-A)
```
```
p =
lambda^2 + 6*lambda + 9
```
```
>> ra = routh(sym2poly(p),eps);
>> r = double(ra)
```
```
r =
1 9
6 0
9 0
```
Обзиром да су сви елементи прве колоне Рут-ове шеме истог знака (позитивни),

закључујемо да је задат систем стабилан.

У наставку је наведен критеријум за испитивање ОУОИ стабилности за

временски континуалне системе.

Временски **континуалан** LTI систем је **ОУОИ стабилан** ако и само ако сви

полови преносне функције Gs() имају негативне реалне делове, односно ако су

сви полови у левој полуравни.

Пример 15. 9 Систем је описан преносном функцијом:

```
2
```
```
32
```
```
21
()
4 5 2
```
```
ss
Gs
s s s
```
```
−+
=
+ + +
```
Испитати ОУОИ стабилност задатог система.

```
>> % I nacin
>> syms s
>> Gs = (s^2-2*s+1)/(s^3+4*s^2+5*s+2)
```
```
Gs =
(s^2 - 2*s + 1)/(s^3 + 4*s^2 + 5*s + 2)
```
```
>> [num den]=numden(Gs)
```

15. Особине модела система

num =
s^2 - 2*s + 1

den =
s^3 + 4*s^2 + 5*s + 2

>> solve(den)

ans =

- 2
- 1
- 1

>> % Svi realni delovi polova prenosne funkcije su
negativni, sistem je stabilan
>> % II nacin
>> num=[1 -2 1];
>> den=[1 4 5 2];
>> [z p k]=tf2zp(num, den) % dobijamo Gs u obliku nula i
polova

z =
1
1

p =

- 2.0000 + 0.0000i
- 1.0000 + 0.0000i
- 1.0000 - 0.0000i

k =
1

>> real(p) % vraca realne delove kompleksnog broja

ans =

- 2.0000
- 1.0000
- 1.0000

>> real(p)<0 % proveramo uslov Re(s)<0

ans =
3×1 **logical** array
1
1
1


15. Особине модела система

Kритеријуми за испитивање асимптотске и ОУОИ стабилности у дискретном

времену

Асимптотска стабилност LTI система у дискретном времену може се испитати на

основу:

- сопствених вредности матрице A
- Јуријевог (енг. Jury) критеријума,

док се ОУОИ стабилност испитује на основу:

- полова преносне функције.

У наставку су наведени критеријуми за испитивање асимптотске, а затим и

ОУОИ стабилности за временски дискретне LTI системе.

Временски **дискретан** LTI систем је **асимптотски стабилан** ако и само ако су

све сопствене вредности матрице A по модулу мање од 1 односно налазе се у

јединичном кругу.

Пример 1 5. 10 Испитати стабилности временски дискретног система описаног

моделом у простору стања на основу сопствених вредности.

####  

5 2 1 2

4 0 0 0 0.5 0.25 0.375 0

0 1 0 0

A B C D

```
− − −   
=  =  = − =
   
    
```
```
>> A = [- 5 - 2 - 1; 4 0 0; 0 1 0];
>> sv = eig(A)
```
```
sv =
```
- 2.0000
- 2.0000
- 1.0000

Пошто све сопствене вредности задатог временски дискретног система нису у

јединичном кругу, може се закључити да систем није асимптотски стабилан.

Сопствене вредности се могу одредити решавањем карактеристичне једначине:

```
>> syms z
>> jd = det(z*eye(3)-A)
```
```
jd =
z^3 + 5*z^2 + 8*z + 4
```
```
>> solve(jd)
```

15. Особине модела система

```
ans =
```
- 2
- 2
- 1

Поред тога, стабилност временски дискретних система се може испитати и

помоћу Јуријевог критеријума.

Јуријев критеријум је метода за испитивање стабилности линеарних дискретних

система помоћу анализе коефицијената карактеристичног полинома. Код

Јуријевог критеријума је могуће одредити да ли је систем асимптотски стабилан

без решавања карактеристичне једначине односно одређивања сопствених

вредности.

За карактеристични полином:

```
1
() 0 1 1
nn
f z a z a z a z ann
−
= + + + − +
```
формира се низ приказан у следећој табели:

```
0
```
```
n
```
_а_

_а_

```
1
```
```
n 1
```
_а_

_а_ −

```
2
```
```
n 2
```
_а_

_а_ −

```
k
```
```
nk
```
_а_

_а_ −

```
1
```
```
1
```
_а_ n

_а_

```
−
```
```
0
```
_а_ n

_а_

```
0
```
```
n 1
```
b

b−

```
1
```
```
n 2
```
b

b−

```
2
```
```
n 3
```
b

```
b−
1
```
```
nk
```
```
k
```
b

b

```
−
```
```
−
```
```
1
```
```
0
```
bn

b

```
−
```
(^)
0
n 2
c
c−
1
n 3
c
c−
2
n 4
c
c−
2
nk
k
c
c
−
−
(^)
.
.
.
.
.
.
.
.
(^)
Јуријев критеријум: Ако је _а_ 0  0 , онда су сви корени fz() у унутрашњости
јединичног круга ако и само ако су (b c d 0 , , , 0 0 ) позитивни.
Другим речима, систем је асимптотски стабилан (корени fz() су у
унутрашњости јединичног круга) ако и само ако су први елементи у непарним
редовима (a b c d 0 , , , , 0 0 0 ) позитивни. При томе, број негативних елемената у


15. Особине модела система

овом скупу је једнак броју корена fz() ван јединичног круга, а нула указује да

је корен на јединичном кругу.

Control System Toolbox не садржи уграђену функцију која формира Јуријеву

шему, али је оваква функција кориснички дефинисана (Epperlein, 2021 ) и јавно

доступна на сајту MathWorks^3. Како би се функција могла позвати, фајл _jury.m_

најпре треба преузети и снимити у Current Folder.

Функција _jury.m_ као улазни параметар прима карактеристичну једначину

задату као полином. Функција враћа две вредности: комплетну Јуријеву

матрицу и низ коефицијената који су битни за тумачење стабилности (елементи

прве колоне матрице на непарним позицијама). Позивом наредбе _help_ може се

добити детаљан опис ове функције.

```
>> help jury
```
Пример 15.1 1 Испитати стабилности временски дискретног система описаног

моделом у простору стања на основу Јуријеве шеме.

```
>> syms z
>> p = det(z*eye(3)-A)
```
```
p =
z^3 + 5*z^2 + 8*z + 4
```
```
>> coef=sym2poly(p)
```
```
coef =
1 5 8 4
```
```
>> [J C] = jury(coef);
>> all(sign(C)==1)
```
```
ans =
logical
0
```
Обзиром да сви непарни елементи прве колоне Јуријеве матрице нису

позитивни, закључујемо да задати систем није стабилан.

Временски **дискретан** LTI систем је **ОУОИ стабилан** ако и само ако су сви

полови преносне функције Gz() по модулу мањи од 1, односно ако се сви

полови налазе у јединичном кругу.

У наставку је наведен критеријум за испитивање ОУОИ стабилности за

временски дискретне системе.

(^3) https://www.mathworks.com/matlabcentral/fileexchange/13904-jury


15. Особине модела система

Пример 15.1 2 Испитати ОУОИ стабилност система, ако је систем описан

преносном функцијом:

```
32
```
```
3
()
4 5 2
```
```
z
Gz
z z z
```
```
+
=
+ + +
```
```
>> num = [1 3];
>> den = [1 4 5 2];
>> [z p k] = tf2zp(num, den)
```
```
z =
```
- 3

```
p =
```
- 2.0000 + 0.0000i
- 1.0000 + 0.0000i
- 1.0000 - 0.0000i

```
k =
1
```
```
>> abs(p) % vraca moduo broja
```
```
ans =
2
1
1
```
```
>> abs(p)<1 % proveravamo uslov |z|<1
```
```
ans =
3×1 logical array
0
0
0
```
```
>> % Svi polovi prenosne funkcije su van jedinicnog kruga,
sistem nije stabilan
```
**Задаци за вежбање**

Задатак 1 5 .1 На основу импулсног одзива анализирати стабилност система

описаног преносном функцијом 2

```
1
()
5 16
```
```
s
Gs
ss
```
```
+
=
++
```
.

```
>> num = [1 1]; den = [1 5 16];
>> Gs = tf(num,den);
>> t = 0:0.1:5;
>> impulse(Gs)
```

15. Особине модела система

Након престанка деловања делта импулсне функције и завршетка прелазног

режима систем је прешао у стационарно стање, те закључујемо да је стабилан.

Задатак 1 5 .2 На основу импулсног одзива анализирати стабилност система

описаног преносном функцијом 2

```
1
()
2
```
```
s
Gs
ss
```
```
+
=
−−
```
```
.
```
```
>> num = [1 1]; den = [1 - 1 - 2];
>> t = 0:0.1:5;
>> impulse(num,den,t)
```
Систем није прешао у стационарно стање, те закључујемо да није стабилан.


15. Особине модела система

Задатак 1 5. 3 Систем је описан преносном функцијом:

#### ( )

```
2
```
```
32
```
55

6 9 2

```
ss
Gs
s s s
```
```
++
=
+ + +
```
а) Испитати управљивост и осмотривост система.

б) Испитати aсимптотску стабилност система преко сопствених вредности.

```
>> [A,B,C] = tf2ss([1 5 5],[1 6 9 2]);
>> Ct = ctrb(A,B);
>> unco = length(A)-rank(Ct)
```
```
unco =
0
```
```
>> % Sistem je upravljiv
>> O = obsv(A,C);
>> unob = length(A)-rank(O)
```
```
unob =
0
```
```
>> % Sistem je osmotriv
>> sopstvene_vrednosti = eig(A)
```
```
sopstvene_vrednosti =
```
- 3.7321
- 2.0000
- 0.2679

```
>> % Sistem je asimptomski stabilan
```
Задатак 15.4 Систем је описан преносном функцијом:

#### ( ) 2

( 3)( 1)

( 1)( 2)

```
zz
Gz
zz
```
```
+−
=
++
```
a) Превести преносну функцију у модел у простору стања.

б) Испитати стабилност система на основу полова преносне функције.

```
>> syms z
>> Gz = (z+3)*(z-1)/((z+1)*(z+2)^2);
>> [num,den] = numden(Gz);
>> [A,B,C] = tf2ss(sym2poly(num),sym2poly(den));
>> [n p k] = ss2zp(A,B,C,[0])
```
```
n =
```
- 3.0000
1.0000


15. Особине модела система

```
p =
```
- 2.0000
- 2.0000
- 1.0000

```
k =
1
```
```
>> % Svi polovi prenosne funkcije su van jedinicnog kruga,
pa sistem nije OUOI stabilan
```
Задатак 1 5. 5 Систем је описан преносном функцијом:

#### ( )

```
2
```
```
32
```
2

8 19 12

```
ss
Gs
s s s
```
```
+
=
+ + +
```
Испитати aсимптотску стабилност система преко Рут-Хурвицове шеме.

```
>> [A,B,C] = tf2ss([1 2 0],[1 8 19 12]);
>> syms lambda, eps
>> p = det(lambda*eye(3)-A)
```
```
p =
lambda^3 + 8*lambda^2 + 19*lambda + 12
```
```
>> ra = routh(sym2poly(p),eps)
```
```
ra =
[ 1, 19]
[ 8, 12]
[ 35/2, 0]
[ 12, 0]
```
```
>> r = double(ra)
```
```
r =
1.0000 19.0000
8.0000 12.0000
17.5000 0
12.0000 0
```
```
>> % Sistem je asimptotski stabilan, jer su svi elementi
prve kolone istog znaka
```
Задатак 15.6 Систем је описан преносном функцијом:

#### ( )

```
2
```
```
32
```
56

2 1.25 0.25

```
zz
Gz
z z z
```
```
++
=
+ + +
```
а) Испитати управљивост и осмотривост система.


15. Особине модела система

б) Испитати aсимптотску стабилност система преко Јуријевог критеријума.

```
>> [A,B,C] = tf2ss([1 5 6 ],[1 2 1 .25 0.25]);
>> Ct = ctrb(A,B);
>> unco = length(A)-rank(Ct)
```
```
unco =
0
```
```
>> % Sistem je upravljiv
>> O = obsv(A,C);
>> unob = length(A)- rank(O)
```
```
unob =
0
```
```
>> % Sistem je osmotriv
>> syms z
>> D = det(z*eye(3)-A)
```
```
D =
z^3 + 2*z^2 + (5*z)/4 + 1/4
```
```
>> coef = sym2poly(D)
```
```
coef =
1.0000 2.0000 1.2500 0.2500
```
```
>> jury(coef)
```
```
ans =
1.0000 2.0000 1.2500 0.2500
0.2500 1.2500 2.0000 1.0000
0.9375 1.6875 0.7500 0
0.7500 1.6875 0.9375 0
0.3375 0.3375 0 0
0.3375 0.3375 0 0
0 0 0 0
```
```
>> % Sistem nije asimptotski stabilan, jer u neparnim
redovima prve kolone nisu sve vrednosti pozitivne, odnosno
imamo nulu (jedan pol je na jediničnom krugu)
```

16. Литература

###### 16. Литература

1. Chapman, S. J. (2015). MATLAB Programming for Engineers (5th ed.). Boston:

```
Cengage Learning.
```
2. Chen, C. T. (1998). Linear System Theory and Design. Oxford: Oxford University

```
Press, Inc.
```
3. Gajić Z., & Lelić M. (1996). Modern Control Systems Engineering. Hoboken:

```
Prentice Hall.
```
4. Etter, D. M., Kuncicky, D. C., & Moore, H. (2005). Uvod u MATLAB 7. Beograd:

```
CET.
```
5. Fitzpatrick J. M. & Ledeczi A. (2017). Computer Programming with MATLAB.
6. Lee, E. A. & Varaiya P. (2011). Structure and Interpretation of Signals and Systems

```
(2nd ed.). LeeVaraiya.org.
```
7. Petrović, B. (1998). Teorija sistema. Beograd: Fakultet organizacionih nauka.
8. Vujčić V., & Petrović B. (1982). Kibernetika. Beograd: Naučna knjiga.
9. MATLAB (2019). Control System Toolbox Getting Started Guide. Natick: The

```
MathWorks, Inc.
```
10. MATLAB (2019). Symbolic Math Toolbox For Use with MATLAB. Natick: The

```
MathWorks, Inc.
```
11. [http://www.mathworks.com](http://www.mathworks.com)
12. Walton R. (2021). mason.m, MATLAB Central File

```
Exchange. https://www.mathworks.com/matlabcentral/fileexchange/22-mason-m
```
13. Epperlein J. (2021). jury.m, MATLAB Central File

```
Exchange. https://www.mathworks.com/matlabcentral/fileexchange/13904-jury
```
14. Rivera-Santos E. (2021). routh.m, MATLAB Central File

```
Exchange. https://www.mathworks.com/matlabcentral/fileexchange/58-routh-m
```

